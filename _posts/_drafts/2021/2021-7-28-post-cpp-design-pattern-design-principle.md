---
layout: post
title: "cpp design pattern - design principle"
subtitle: '[structual pattern] c++设计模式之设计原则'       
author: "twistfatezz"
header-style: text
# header-img: "img/in-post/economics_1/headimg.png"
# header-mask: 0.8
comments: false 
mathjax: false 
date: 2021-07-28 15:44
lang: ch 
catalog: true 
categories: cpp 
tags:
  - Time 2021
  - cpp design pattern
---
#### 单一职责原则(single responsibility principle, SRP)
1) 就一个类而言，应当只有一个引起它变动的原因。<br>
2) 如果一个类承担的职责过多，在类的内部的职责耦合度将非常高，一个职责的变动就可能会影响甚至削弱该类别完成其他职责的能力。这种单一类型内部高度耦合的设计，静态使用可能不会产生问题，但在需求不断变动的情况下，实际上是非常脆弱的。<br>
**3) 软件设计的一个重要的任务就是合理地从高度抽象的任务中，进行逻辑上和代码上的解耦合，从而将负责不同职责的模块独立出来，以便于灵活开发维护**。<br>
<p align="right">Ref. 大话设计模式 chapter3 p30</p>


#### 开放闭合原则(the open-closed priciple, OCP)
1) 软件实体(类型、模块、函数等)应该可以扩展，但是不可以修改。<br>
**2) 面对新的需求，对程序的改动应当是通过增加新的代码来完成，而不是将现有的代码进行改动(open for extension, close for modification)**。<br>
3) 我们希望在开发工作展开不久就知道程序需求可能发生的变化，越晚预知到程序可能发生的变化，则越难在程序设计时找到一种合适抽象体系对于问题进行描述解决。<br>
4) 开放-封闭原则是面向对象的程序设计的核心所在，遵循这个原则可以带来"面向对象进行程序设计声称的巨大益处"：可维护、可扩展、可复用、灵活性好。<br>
5) 开发人员应当仅对程序中频繁变动的那些部分进行抽象，但对于应用程序的每个部分进行抽象并不是一个好主意，拒绝不成熟的抽象同样重要。<br>
<p align="right">Ref. 大话设计模式 chapter4 p34</p>


#### 依赖倒装原则(dependance inversion principle, DIP)
1) 高层模块不应该依赖底层模块。底层模块和高层模块都应该依赖于抽象。<br>
**2) 抽象不应该依赖于细节，细节应该依赖于抽象。要面向接口编程，而不是面向具体实现编程**。<br>
3) 依赖倒装法则是面向对象编程的核心思想。<br>

**Example**：电脑内部结构设计同应用程序设计一样，使用了依赖倒装原则：主板、CPU、内存、硬盘都是在针对接口设计的，这保证了这些电脑组件很大程度上的通用性；如果这些组件针对具体实现来进行设计，那么内存就应当对应特定型号的主板，它们之间产生较大的耦合性，如果升级主板则需同时更换内存，带来很多拓展性的麻烦。<br>
**Reminds**：即使面对的问题是具体的，在编写相关应用程序时，也需考虑需求变动的频率，对于需求变动频率较高的部分，应当将具体问题中相应的部分进行抽象，并为其提供有效接口进行具体问题解决。不要面向具体问题本身进行程序设计，代码的组织性较差，且难于扩展。
<p align="right">Ref. 大话设计模式 chapter5 p38</p>


#### 里氏代换原则(Liskov substitution principle, LSP)
1) 软件中客户端应用程序中的子类型应该能够代替它的父类型。一个软件实体客户端程序如果使用的是所构建类型层次结构中的父类，那么该客户端程序也应该适用于其子类，并且客户端程序不应当察觉出父类对象和子类对象的区别。也就是说，软件中，如果将适用父类的代码全部替换成子类，软件的行为不能出现变化。<br>
2) 只有当子类替换掉父类，软件单位中的功能不受影响时，父类才能够真正的被复用，而子类也能够真正的在父类的行为基础上添加拓展功能。

**Example**：在一个软件中，如果鸟类有fly方法，那么企鹅继承自鸟类满足里氏代换原则么？答案：显然不满足。子类只能继承基类非private的属性、方法，如果客户端代码中有使用鸟类fly方法的对象，则该类型不能替换成企鹅类型(企鹅类没有fly方法)。<br>
**Reminds**：一个软件设计中如果遵循里氏代换原则，则由于软件中所有使用父类的地方都可以替换成子类型，则该应用程序可以在不修改原有的类层次结构的情况下，进行功能扩展(直接添加派生子类，再修改客户端代码即可)。
<p align="right">Ref. 大话设计模式 chapter5 p41</p>


#### 迪米特法则(Law of Demeter, LoD)
1) 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的方法，则可通过第三方转发此调用。<br>

**Reminds**：迪米特法则实际上强调类型之间低耦合。类型之间的耦合性越低，越有利于该类型实现复用。弱耦合的类型被修改，对于其他关联类型的影响甚微，所以低耦合类型更加易于扩展。
<p align="right">Ref. 大话设计模式 chapter11 p100</p>


#### 合成/聚合复用原则(composite/aggregate reuse principle, CARP)
**1) 尽量使用合成/聚合，尽量不要使用类型继承**。<br>
2) 合成表示一种"强"的拥有关系，体现了严格的部分和整体的关系，即部分可整体的生命期一致。<br>
3) 聚合表示一种"弱"的拥有关系，体现的是A对象可以包含B对象，但是B对象不是A对象的一部分。<br>

**Reminds**：优先使用合成/聚合有助于每个设计的类型的封装性，并集中在单个任务上。这样每个类层次结构都会保持很小的规模，并且不太可能增长为不可控的庞然大物(类继承层次较为复杂时，非常难于维护、拓展)。

<p align="right">Ref. 大话设计模式 chapter22 p225</p>

#### 敏捷开发原则(agile develop principle, ADP)
**1) 不要为代码添加基于猜测的、实际不需要的的功能**。<br>

**Reminds** 如果不清楚一个系统是否需要[命令模式](http://localhost:4000/cpp/2021/08/06/post-cpp-design-pattern-command/)，一般不要急于去实现它。实际上，在需要时，通过代码重构拓展这个功能并不困难。只有真正需要如：撤销、恢复等功能时，将原来的代码重构为命令模式才有意义。


<p align="right">Ref. 大话设计模式 chapter23 p?</p>

#### Reference
> \<大话设计模式\> chapter4 p52 <br>

> 1 当使用inline数学公式且公式经过GFM排版之后都在同一行 使用`$...$`符号<br>
> 2 当希望数学公式单独成行或者经过GFM排版之后占用多行 应当使用`$$...$$`符号<br>
> 3 对于表示条件概率 需要表示竖线的时候`|` 应当使用`\mid` 而不是直接在键盘上打出`|` => 容易被编辑器认为是一个md制表符<br>
> 4 在md引入图片的时候 不要使用`<center>`和`</center>` 在这篇文档的编辑过程中vscode的preview插件在使用了上述符号之后 导致下一段的数学公式预览显示不正常<br>
> 5 使用md的时候 单独的两段文字上下需要空出一行<br>
> 6 想要强制换行的时候 需要使用`<br>`而不是`<enter>`<br>
> 7 特殊字符如果想要避免和md解析关键字冲突 应当使用``将关键字包含在内 <br>
> 8 `<center><img src="/img/in-post/economics_4/xxx.png" width="60%"></center>` <br>
> 9 使用html设置图片文字环绕方式: <br>
    `<div>` <br>
        `<img src="/img_path" align="left" width="40%" hspace="" vspace=""/>` <br>
        `<p>paragraph1 around the picture</p>` <br>
        `<p>paragraph2 around the picture</p>` <br>
        `<p>paragraph3 around the picture</p>` <br>
    `</div>` <br>
> 10 `<font style="color:red; font-weight:bold">加粗蓝色</font>`用来设置字体位置和颜色
