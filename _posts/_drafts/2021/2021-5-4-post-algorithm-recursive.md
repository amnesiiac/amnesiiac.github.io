---
layout: post
title: "recursive method"
subtitle: '[数据结构与算法] - 递归算法及递归消除'
author: "twistfatezz"
header-style: text
# header-img: "img/in-post/economics_1/headimg.png"
# header-mask: 0.8
comments: false 
mathjax: true
date: 2021-05-04 11:30
lang: ch 
catalog: true 
categories: algorithm 
tags:
  - Time 2021
---
### 递归思想简介
递归是函数和过程调用的一种特殊形式：允许函数和过程进行自我调用。递归的价值：许多问题都可以简洁而准确的抽象成递归的形式(如：目录的定义方式)，并且可以减少代码量，提高代码可读性。<br>
递归包括：线性递归、二分递归和多分枝递归等形式，以实现遍历、分治等算法策略。

### 线性递归
**[线性递归定义]** 线性递归问题总可以分成两个问题：**[可求解问题:]** 一个是对应单个元素(或者少量元素)，要求这个子问题可以直接求解；**[剩余问题:]** 除了上述可求解子问题之外的问题，要求这个子问题需要和原来的问题同构。<br>

**[线性递归的思想：减而制之]** 减而制之(decrease and conquer)的思想：递归每深入一层，带求解问题的规模都缩小一个常数，直至退化成平凡的小问题。

**[线性递归例子]** 
```c++
int sum(int a[], int n){
    assert(n>=0);
    if(n==0){return 0;}// [可求解问题] - 递归的终止条件
    else{
        return sum(a, n-1)+a[n-1];// [剩余问题] - 递归的过程
    }
}
```
**[上述例子算法复杂度分析]** <br>
**单次递归复杂度分析:**执行一个if判断，执行一次加法，return返回语句返回值，时间复杂度为`O(3)`。<br> 
**递归深度:** sum(a,n)->sum(a,0)，则深度为`n+1`。<br>
**时间复杂度:** `O(3)*O(n+1)=O(n)`。<br>
**空间复杂度:**
如下图所示，将每次递归的状态都列举出来，很容易发现：内存中需要存储的元素为`a[0] a[1] a[2]... a[n-1]`，即这个递归调用的空间复杂度正比与其深度n，即`O(n)`。

<center><img src="/img/in-post/algorithm_img/recursive_1.png" width="60%"></center>

**[注意问题的划分:]** 递归问题总是划分成：可求解问题(递归基)+剩余问题的模式(和原问题同构)。问题的划分方式将会影响到整体算法的执行效率，如<<数据结构-邓俊辉>>p20的例子，所以我们在分解递归问题时，需仔细考虑问题的各种可能的切入点，找到最有效率最省资源的解法。

### 递归消除
递归算法空间复杂度和递归的深度相关，并且，需要大量的资源用于递归过程中创建、维护以及销毁各种递归实例对象，在运行速度要求很高，空间资源紧缺的条件下，需要将递归版本修改成非递归版本。<br>
下面给出一个线性递归的例子用于反转数组中的元素：
```c++
void reverse(int arr[], int h, int l){
    if(h>l){// 剩余问题
        swap(arr[h], arr[l]);
        reverse(arr, h-1, l+1);// 尾递归:递归调用在最后一步出现
    }
    else{;}// 可求解问题 h=l; h<l;
}
```
**[尾递归的改写]** 在线性递归算法中，若递归调用恰好在整个问题解决步骤中最后一个出现，则称之为`尾递归`。针对尾递归的形式，有一种较为通用的改造方式：
```c++
// goto语句消除尾递归
void reverse(int arr[], int h, int l){
    next:// no.1: 首先在解决问题起始位置之前插入goto跳转flag
        if(h>l){// 剩余问题
            swap(arr[h], arr[l]);
            h--; l++;// 缩小问题规模
            goto next;// no.2: 将原来的递归调用替换成goto语句
        }
        else{;}// 可求解问题(递归基)
}
```
```c++
// goto语句不符合书写规范 用while语句消除goto 简化尾递归
void reverse(int arr[], int h, int l){
    while(h>l){
        swap(arr[h], arr[l]);
        h-=1; l+=1;
    }
}
```
实际上，严格地定义下，`尾递归`应该是算法解决问题步骤中，逻辑上最后一个进行的操作是递归调用，才称之为尾递归。因此，第一个`sum`函数的例子并不是尾递归，因为最后一步在执行完递归调用`sum()`之后还要执行加法操作。但是它消除递归方式和本例相同：
```c++
// goto方式消除递归
int sum(int a[], int n){
    int sum=0;
    next:// 开始处 添加goto标志位
        if(n<1){return sum;}
        else{
            n--;// 解决问题
            sum+=a[n];// 解决问题
            goto next;// 最后一步 添加goto跳转语句
        }
}
// while方式改进goto方式
int sum(int a[], int n){
    int sum=0;
    while(n>=1){// 通过while 消除了 flag - goto flag模式
        n--;// 解决问题
        sum+=a[n];// 解决问题
    }
    return sum;
}
```

### 二分递归
和线性递归中的`减而制之`的策略一致，二分递归基本思想也是将原问题规模缩小进行问题求解，不同的是，二分递归采用将原问题`一分为二`，以缩小问题规模。经典例子计算fibonacci数：

$$
fib(n)=
\left\{\begin{array}{ll} 
n & (n \leq 1) \\ fib(n-1)+fib(n-2) & (n \geq 2) 
\end{array}\right.
$$

```c++
int fib(int n){
    return (n>=2?) fib(n-2)+fib(n-1) : n;
}
```

根据上面的通项公式，可以非常直观看到，整个问题的求解被分成两个部分`f(n-2)`和`f(n-1)`进行。<br>
但是，这种方法的时间复杂度太高，在实际应用中没有使用价值。<br>
**[优化策略]** 在二分递归算法中，可能存在很多冗余重复的计算。<br>
**[策略1 - 制表法]** 可以借助一定辅助空间，在递归子问题求解完成后，记录结果；后面的子问题求解前，先查阅记录获得解答，然后再进行问题解决，可以有效避免重复计算问题。<br>

```c++
// 这种写法是tail recursive的 可以被优化成simple loop
// n:迭代的次数 current=fib当前值 prev=fib前一项值
int fib(int n, int current=1, int prev=0){
    if(n==0){return prev;}// 递归基
    else{
        // 进行一次迭代 新的当前值=pre+cur 新的前一项值=旧的当前值
        return fib(n-1, prev+current, current);// 剩余问题
    }
}
```
**[思路整理:]** 尽量问题模型本身进一步挖掘本质，通过找到合适的问题切入点，可以有效优化算法。<br>
根据fib算法：二分计算有很多重复的递归，因此，可以通过增加递归调用的宽度(状态数)的方式来减少重复递归次数(递归长度)：上面代码添加了两个状态，当前fib值，前一个fib值，每个状态和迭代次数n直接相关，因此迭代函数状态数为3(二分递归的状态数为1)。


**[策略2 - 动态规划]** 可以从递归基出发，自底而上地逐步进行问题解决fib问题。<br>
```c++
int fib(int n){
    int current=1; int pre=0;// dp初始状态
    while(n>0){// 状态转移 - 从初始状态逐步推演
        current+=pre;
        pre=current;
        n--;
    }
    return pre;
}
```
更多关于动态规划方法整理内容见[dynamic programming](/algorithm/2021/05/04/post-cpp-dynamic-programming/)。

## Reference
> <<数据结构>> 邓俊辉

> 1 当使用inline数学公式且公式经过GFM排版之后都在同一行 使用`$...$`符号<br>
> 2 当希望数学公式单独成行或者经过GFM排版之后占用多行 应当使用`$$...$$`符号<br>
> 3 对于表示条件概率 需要表示竖线的时候`|` 应当使用`\mid` 而不是直接在键盘上打出`|` => 容易被编辑器认为是一个md制表符<br>
> 4 在md引入图片的时候 不要使用`<center>`和`</center>` 在这篇文档的编辑过程中vscode的preview插件在使用了上述符号之后 导致下一段的数学公式预览显示不正常<br>
> 5 使用md的时候 单独的两段文字上下需要空出一行<br>
> 6 想要强制换行的时候 需要使用`<br>`而不是`<enter>`<br>
> 7 特殊字符如果想要避免和md解析关键字冲突 应当使用``将关键字包含在内
