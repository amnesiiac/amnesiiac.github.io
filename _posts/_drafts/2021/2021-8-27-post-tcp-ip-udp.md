---
layout: post
title: "tcp-ip: udp (用户数据报协议)"
subtitle: '[tcp-ip: illustrated vol1] - chapter11' 
author: "twistfatezz"
header-style: text
# header-img: "img/in-post/economics_1/headimg.png"
# header-mask: 0.8
comments: false 
mathjax: false 
date: 2021-08-27 15:52
lang: ch 
catalog: true 
categories: tcp-ip 
tags:
  - Time 2021
  - tcp-ip illustrated vol1 
---
### 引言
面向流(stream-oriented)的协议(如TCP)在输出数据时，应用程序写入的数据量和单个IP数据报实际发送的数据量关系不大。<br>
不同于面向流的协议，UDP是一种简单的面向数据报的传输层协议，计算机进程中每个输出操作都会产生一个UDP数据报，并进一步封装成待发送IP数据报。即进程操作和产生的UDP数据报的数量呈现一定关系。<br>
RFC-768是描述UDP实现的正式规范。

**UDP数据报封装成IP数据报的方式**
<center><img src="/img/in-post/tcp-ip_img/udp_1.pdf" width="60%"></center>

**UDP的不可靠性** <br>
UDP传输协议不保证传输的可靠性，它只负责将应用程序传输给IP层的数据报发送出去，但不能保证数据报达到目的地。虽然它是一种不可靠协议，而TCP是一种可靠的协议，但是并不是所有情况下，都需要使用TCP协议；UDP和TCP各有千秋，各有用武之地。

**IP数据报的长度 & 网络路径MTU & IP数据报分片** <br> 
UDP封装成IP数据报进行发送，因此应用程序必须关心IP数据报长度，IP数据报的长度需要收到IP首部中相应字段的限制，同时应用程序应当关注路径MTU对于IP数据报长度的限制。如果长度超过了MTU，则需进行IP分片。

### UDP首部
UDP首部各字段如下图所示。
<center><img src="/img/in-post/tcp-ip_img/udp_2.pdf" width="70%"></center>
上图中"if has"表明可以发送一封空的UDP数据报，此时UDP数据报的长度为8byte。

**UDP端口 & TCP端口** <br>
在IP数据报的首部中，包含一个协议字段值用于区分UDP数据、TCP数据。应用程序接收到IP数据报后，根据收到数据报的协议字段，TCP端口的数据收发交给TCP服务程序监听，UDP端口号数据收发由UDP服务程序进行监听。TCP端口号和UDP端口号相互独立，但是UDP和TCP可能使用相同的端口号(e.g. UDP和TCP同时提供某种"知名"的服务)。

### UDP校验和
##### 1 UDP校验和和IP校验和的对比
**i** UDP校验和的计算覆盖了UDP首部以及UDP数据。IP首部的校验和只负责IP首部的校验，不负责IP数据部分的校验。<br>
**ii** UDP校验和是可选的，而TCP的校验和是强制的。<br>
**iii** UDP校验和和IP校验和的计算方法类似，都是计算16bit字的二进制反码和。<br>
**iv** UDP数据可能出现奇数字节，因此在校验和算法计算之前进行补0操作(补充至16bit的倍数)，详见UDP伪首部图如下。需要说明的是，补充的0值不参与信息的传输。<br>
**v** UDP数据报和TCP数据报都包含一个12byte长的伪首部。伪首部是为了计算检验和而设置的。伪首部包含一些IP首部字段(源地址、目的地址)，其目的是为了2次检查数据是否到达正确的目的地(2次确认IP没有接受不属于本机的数据报、2次确认IP没有将发给其他协议层的数据报发给UDP服务程序)。

##### 2 UDP伪首部数据报格式图
<center><img src="/img/in-post/tcp-ip_img/udp_3.pdf" width="60%"></center>

##### 3 关于UDP的检验和
UDP的检验和是一个端到端的检验和，由发送端计算，由接收端验证。目的是为了检测UDP数据报首部&数据在"发送端-\>接收端"之间发生改动。

**[1] 关于校验和的发送端&接收端计算方法说明** <br>
**发送端：** 发送端对于每个16bit字计算其2进制反码，并将所有UDP首部&数据中的计算得到的反码对应位相加，得到发送端天填充的校验和。<br>
**接收端：**接收端再次计算收到数据报的校验和，由这次计算包含了发送端写入的校验和，因此结果应该为全1，如果实际计算结果不是全1，表明传输过程信息有误，则悄悄丢弃该数据报(不发送任何差错报文)。

**[2] 关于校验和3种情况的说明** <br>
**i** 如果16bit检验和的计算结果为全0，则发送端写入UDP数据报的值为全1(取2进制反码写入数据报)。**ii** 如果接收端收到的检验和为0，说明发送端没有计算检验和。**iii** 如果发送端没有计算检验和，但是接收端检测到检验和有误，则该UDP数据报被悄悄丢弃(不会产生任何差错报文)。

**[3] 关于UDP校验和的必要性说明** <br> 尽管UDP校验和功能是可选字段，但是使用它仍然是必要的。在数据报通过路由器时，对链路层数据帧进行循环冗余校验，可以检查到大部分差错。路由器中也会存在软件&硬件差错，这些错误可能会修改数据报中的数据报，不使用UDP校验和这些错误将不能被检测出来。另外，一些数据链路如SLIP没有任何形式的链路校验机制，因此UDP协议层面的校验是必要的。<br>
Host Requirements RFC声明：UDP检验和和选项默认情况下应该打开，并且，如果发送端计算了校验和写入UDP数据报，那么接收端必须检验收到的校验和是否正确。

**[4] 通过tcpdump命令的输出查看特定系统是否开启UDP校验和** <br>
使通过编写sock程序在某个主机上发送9字节数据到其他的主机的回显服务中。再使用用"tcpdump -v/-vv/-vvv"系列命令打印更加详细的输出，以查看数据报中udp校验和cksum。

上述操作得到的输出结果如下图所示：
<center><img src="/img/in-post/tcp-ip_img/udp_4.pdf" width="100%"></center>
从上述案例可以看出，udp校验和只能检测传输错误，但是对于"调换位置"类型的错误却无能为力(调换前后校验和相同)。

**[5] 在繁忙的服务器上统计检验和差错数** <br> 
分别在以太网链路层、IP通信网络层、UDP协议、TCP协议传输层对于大致发送的总的各个类别数据报分组数进行统计，并且对于各个层次的校验和差错数量进行累计，得到的结果如下图。
<center><img src="/img/in-post/tcp-ip_img/udp_5.pdf" width="40%"></center>

各个层次数据报的总数只有参考意义，不具备真实计算意义：并不是所有的以太网帧数据报了都是IP数据报，至少还包括ARP请求&应答数据报；同样的，也并不是所有的IP数据报都是TCP或者UDP，因为ICMP也借助IP封装传送数据。<br>
上图中的校验和差错表明：不能完全相信链路层CRC校验，在所传输的数据价值很高的情况下，也不要完全相信TCP/UDP的校验和，因为这些校验和都是较为简单的校验，不能检测出所有可能发生的差错。

### IP分片(IP fragmentation)
物理网络层一般要限制每次发送的数据帧的最大长度，当IP层收到一份待发送的数据报时，需要判断向本地哪个接口发送IP数据报(routing)，并查询该接口以获得其MTU。IP层将数据长度和查询得到的MTU相比较，数据报长度\>MTU则进行分片。

##### 1 IP分片&重组装的位置
IP分片的过程可以发生在源主机上，也可以发生在中间路由器上。IP数据报在下一站目的主机进行重新组装(由IP层完成)，其目的是使IP数据报分片、重新组装过程对传输层(TCP/UDP)是透明的(排除某些越级操作 )；解释：如果在源主机&中间路由器中发生了IP分片，但直到目的主机才进行重组装，那么被分片的IP数据报对于中间路由器的传输层(TCP/UDP)是不透明的，即中间的传输层协议不知道该数据报是分片的。<br>
另外，已经分片的IP数据报还有可能会继续分片，IP首部字段为数据报分片&重组装提供了足够的信息。

##### 2 IP首部包含关于分片相关信息
**IP数据报16bit标志位** 对于发送端发送的每份IP数据报来说，其表示字段都包含唯一的数值，当IP数据报被分成多个片时，该数值被复制到每个片中。<br>
**3bit-MF标志位** 3bit标志位中第三个bit(more fragments, MF)用于表示"还有更多的分片"，除了最后一片外，其余IP数据片都将该bit置为1以表示当前片不是IP数据分片的最后一片。<br>
**3bit-DF标志位** 3bit标志位中第二个bit(dont fragment)用于禁止IP对于该数据报进行分片(将该标志位置为1)。当实际传输数据时，如果发现该数据报需要被分片但是设置了禁止分片标志位。
**IP数据报13bit片偏移字段** 该字段显示了该片从原始IP数据报起始处偏移的位置(即使到达目的地后，IP数据报分片发生失序，也能根据片偏移信息对于数据片进行重组恢复)。<br>
**IP数据报16bit总长度** 当IP数据报被分片后，每个数据片的16bit总长度将改成该数据片的长度。

##### 3 尽量避免IP数据报分片
尽管IP数据报分片对于每个传输路由器似乎都是透明的，但是有一些其他考量需要避免IP数据报分片。

即使传输过程中只丢失了一个IP数据报分片也需要重新传递整个数据报。这是因为IP层本身没有超时重传机制，TCP有重传机制但是UDP没有。因此即使TCP数据报封装成IP数据报在传输过程中只丢失一片，也需要借助TCP重传机制重传整个TCP数据报，没办法只重传一个数据片。

无法在源主机端重传一个数据片的原因是：IP数据报很可能是被中间路由器分片的，因此源主机并不知道该数据报被如何进行分片，也就不能定位&发送该丢失数据片[参考自:Kent and Mogul 1987]。

##### 4 运行sock程序&使用tcpdump分析数据报输出情况
**[1]** 编写socket程序分别按照1471byte、1472byte、1473byte、1474byte数据报长度发送UDP数据报。命令行程序调用输入如下图。socket程序的相关描述参考\<tcp-ip: illustrated appendix-c\>。
<center><img src="/img/in-post/tcp-ip_img/udp_6.pdf" width="100%"></center>

**[2]** 使用tcpdump命令对于上述sock程序发送的数据报进行抓包，并答应发送数据报详情如下图。
<center><img src="/img/in-post/tcp-ip_img/udp_7.pdf" width="100%"></center>

**[3]** 上述4封数据报中第三封长度为1473byte的UDP数据报分组方式可用下图进行表示。从下图很容易看出：只有第一片IP数据报包含UDP首部，其余的UDP数据报分片只包含IP首部；因此上面tcpdump命令中，只有第一片UDP数据报能够打印出源、目的端口号，其余分片无法打印端口信息。
<center><img src="/img/in-post/tcp-ip_img/udp_8.pdf" width="70%"></center>

### ICMP不可达差错报文(fragment needed)
之前在[chapter8-traceroute](http://localhost:4000/tcp-ip/2021/08/15/post-tcp-ip-traceroute/)中介绍过，traceroute程序通过判断返回的UDP应答是否为ICMP端口不可达差错报文来确定源主机到目的主机的TTL。<br>
本文提供另一种场景下产生ICMP不可达数据报：当路由器收到一份需要分片的数据，而IP首部设置了不允许分片标志位(DF)，此时转发该数据报的路由器将会返回一封ICMP不可达数据报，该数据报的格式和之前chapter6-ICMP中提到的ICMP不可达数据报通用形式不同(相比标准格式改变了ICMP类型、未用字段中的高16bit填写下一站网络MTU)。

##### 1 ICMP不可达差错报文数据格式
RFC[Almquist 1993]规定，当IP分片和标志位冲突需要发送ICMP不可达差错报文时，必须采用这种格式进行发送。当路由器不能支持发送这种格式的报文时，将"下一站MTU"字段设置为0。
<center><img src="/img/in-post/tcp-ip_img/udp_9.pdf" width="70%"></center>

##### 2 使用ping程序发送ICMP回显数据报的方式测试SLIP线路MTU限度
使用ping程序发送的ICMP回显数据报测试点对点线路MTU的依据是：不断增加发送的数据报分组长度，直到使用tcpdump程序捕获的数据报发现分组数据报为止。

**[1] ping程序ICMP回显请求数据报发送流程示意图**
<center><img src="/img/in-post/tcp-ip_img/udp_10.pdf" width="70%"></center>

**[2] 在bsdi主机上运行tcpdump命令截获数据报并打印结果如下图**
<center><img src="/img/in-post/tcp-ip_img/udp_11.pdf" width="100%"></center>

**[3] 补充说明** <br>
chapter3-9中通过netstat命令的输出中包含接口MTU数值；本部分使用ping程序通过收发ICMP回显应答报文的方式也可以测试SLIP线路两个方向上的MTU数值；另外，chapter25中可以使用SNMP来对于SLIP线路的两个方向上的MTU进行判断(点到点链路中不同方向上的MTU数值可以不同)。

### 使用traceroute程序确定\<路径MTU\>
大多数系统不支持路径MTU发现功能，但是很容易修改traceroute程序，并用它来确定路径MTU数值。

##### 1 traceroute程序测试路径MTU发现流程原理
**(i)** 首先用主机发送一封数据报，长度恰好为主机端口出口MTU数值。<br>
**(ii)** 当主机收到ICMP不可达(无法分片)数据报时，就减小数据报长度，再重发一封新的数据报。<br>
**(iii)** 如果中间路由器返回的ICMP不可达(不能分片)数据报是本文所描述的格式，即包含出口MTU数(下一站MTU数值)，那么 重发的数据报长度就设置为ICMP不可达(不能分片)报文包含的出口MTU数值来发送。否则就使用MTU建议数值表中的下一个较小的数值作为数据报的长度进行发送。<br>
**(iv)** RFC-1191声明：MTU数值的个数是有限的，因此traceroute程序本身存放了一些MTU建议近似值构成的表。当中间路由器没有返回发送端口的MTU数值给源主机时，从表中选取下一个建议的MTU数值进行发送。 

##### 2 traceroute程序用于路径MTU发现
使用traceroute程序判断从sun主机到slip主机的路径MTU，已知SLIP线路的MTU为296。

**[1] 使用traceroute程序判断sun主机到bsdi主机的路径MTU - bsdi返回普通类型的ICMP报文**
<center><img src="/img/in-post/tcp-ip_img/udp_12.pdf" width="100%"></center>

**[2] 使用traceroute程序判断sun主机到bsdi主机的路径MTU - bsdi返回用于分片的ICMP报文**
<center><img src="/img/in-post/tcp-ip_img/udp_13.pdf" width="100%"></center>

对比分析上述两种报文，可以很容易发现，bsdi主机支持发送专门用于分片的ICMP不可达报文。使用专门用于分片的ICMP不可达报文可以极大程度上减少路径MTU发现所发送的探查数据报的数量，减少探查时间。

### 采用UDP的路径MTU发现(案例)
在chapter1中通用主机网络结构中各个主机、路由器系统中，唯一支持MTU发现机制的是"solaris 2.x"系统，因此本案例从solaris主机上使用sock命令向slip主机发送UDP数据报以测试路径MTU发现过程。

编写相关sock程序，并使用如下命令产生650byteUDP数据报，并从solaris主机按照规定格式连续发送10次长度为650byte的UDP数据报。<br>
sock程序命令行调用方式如下所示："solaris %sock -u -i -n10 -w650 slip discard"。

##### 1 案例网络路由结构示意图
<center><img src="/img/in-post/tcp-ip_img/udp_14.pdf" width="50%"></center>

##### 2 使用tcpdump命令对使用普通ICMP不可达报文的路径MTU发现机制进行观测
<center><img src="/img/in-post/tcp-ip_img/udp_15.pdf" width="100%"></center>
**补充说明** <br>
**(i)** 上图中第7行重新设置DF(don't fragment)标志位是因为：此处发生了IP定时器超时，即需要在特定时间间隔内，重新设置DF标志位为1，并重新运行路径MTU发现机制。上述重置DF=1的数据报主要目的是：通知IP层查看(重新确定)路径MTU是否增大了。将案例中第7行和第19行的时间进行比较可以发现：程序设置每隔30s重置DF=1并发送数据报，以探查链路MTU是否变化。<br>
**(ii)** 每隔30s重置一次DF标志位不是非常合理，重置间隔太短了。RFC-1191建议DF标志位重置间隔时间应该为10min。另外，重置时间可以通过ip_ire_pathmtu_interval进行实现。<br>
**(iii)** tcpdump输出第5行IP层发现650byte超过了bsdi主机的端口MTU数值，没有指定专门用于分片的ICMP报文，因此IP层查询MTU表"推断"下一个最可能的链路MTU数值为576byte。于是将数据报分成552+106的两部分进行发送。<br>
**(iv)** 显然，查表所得的路径MTU数值是错误的，真实的bsdi到slip主机链路MTU数值为256byte。这意味着经过solaris主机分片的数据报还将继续被bsdi主机分片。在solaris主机发送数据报时，不应该对其进行分片，也不应该在抽到普通ICMP不可达报文后，根据"查表"而得到的建议值对于数据报进行"预先分片"。正确的做法是：不对发送的数据报分片，并且置DF标志位=0。<br>
**(iv)** 案例使用的solaris系统无法针对单个UDP应用程序(端口)关闭路径MTU发现机制，只能在系统级别关闭MTU发现机制(借助ip_path_mtu_discovery)。

##### 3 使用tcpdump命令对使用用于IP分片的ICMP不可达报文的路径MTU发现机制进行观测
按照正确的做法(使用专门用于分片的ICMP不可达数据报文格式重新运行案例，并使用tcpdump程序打印输出结果如下。
<center><img src="/img/in-post/tcp-ip_img/udp_16.pdf" width="100%"></center>
这种方式由于ICMP不可达报文(用于分片)可以通知源主机路径MTU数值，可以大大减少UDP数据报在发送时产生的数据碎片。

### UDP和ARP之间的交互作用
编写相关sock程序，用来产生一个8192byte长度的UDP数据报。在bsdi主机上运行该sock程序发送数据报到svr4主机。在程序运行之前确保ARP高速缓存是空的，因此在发送第一封IP数据报(数据报分片)之前必须交换ARP请求&ARP应答。

**[1] bsdi主机和svr4主机网络拓扑结构关系如下图**
<center><img src="/img/in-post/tcp-ip_img/udp_17.pdf" width="60%"></center>

**[1] 相关程序如下图**
<center><img src="/img/in-post/tcp-ip_img/udp_18.pdf" width="100%"></center>

**[2] 预计程序运行流程及其问题** <br>
**(i)** IP数据报长度(8192byte)大于bsdi主机出口MTU数值(1500byte)，需要进行IP数据报分片(分6片)。<br>
**(ii)** 在第一份IP数据报分片发送之前，需要完成ARP请求&应答。<br>
**(iii)** 是先发送ARP请求还是先完成IP数据报分片?在收到ARP应答之前数据报分片是否已经准备好? <br>
**(iv)** 为什么下图中发送了6封ARP请求，但是返回了7封ARP应答？(这是一个无法解释非正常现象)

**[3] 实际程序运行流程&分析** <br>
在bsdi主机上运行tcpdump命令打印收发IP数据报的情况如下图，并进行分析，
<center><img src="/img/in-post/tcp-ip_img/udp_19.pdf" width="100%"></center>
**(i)** 在第一份ARP应答在bsdi主机上被收到之前，共产生6个ARP请求(不是预想的1个)，原因可能是因为发送ARP请求在IP数据报分片之后，因此每个IP数据报分片都产生一份ARP请求；或者可以理解成：ARP请求的产生&发送很慢，但是IP数据包分片很快，因此IP数据报分片总是在ARP请求产生之前完成。<br>
**(ii)** 在收到第一份ARP应答后(图中第7行)，只将最后一份数据报分片进行发送(图中第9行)。看起来好像将前几封数据报分片都丢弃了。事实上，这种操作在ARP协议中是很常见的：在ARP大多数实现中，等待ARP应答时，只将最后一份IP数据报分片发送给目的端。这大概和ARP处理输入队列时采用LIFO的顺序有关，最后一份处理队列中的ARP请求将第一个被发送。<br>
**(iii)** Host Requirements RFC要求ARP实现过程中，必须防止这种ARP flooding现象：即针对同一个IP目的地址快速发送大量的ARP请求(IP数据报分片是ARP flooding现象的原因)。RFC建议的同一IP目的地址的ARP发送频率限制为1次/s，而本例中为6次/4.3ms。<br>
**(iv)** Host Requirements RFC要求至少应该保留一份IP数据报分片报文，并且这份报文必须是IP数据报分片的最后一份报文。上图中，在收到第一份ARP应答后，只将最后一片IP数据报分片发送给目的主机(图中第9行)。<br>
**(v)** 如果在上图中第7个ARP应答返回后，继续运行tcpdump程序而不将它关闭，以验证是否目的主机svr4会返回"ICMP组装超时"数据报。结果：并不会返回"ICMP组装超时数据报"。原因：在目的主机svr4上，第一个IP数据报分组被接受后，IP层启动一个定时器(一般设定定时时间为30s或者60s)，如果定时器超时但数据报分片并未完全到达，则目的主机丢弃收到的数据报。如果目的主机不丢弃该数据报，则由于总是有部分IP数据报分片无法完全的到达，那么迟早会导致目的主机数据报缓存存满溢出。

### UDP数据报长度的限制 
理论上，IP数据报最大长度为65535byte，这是由于存放IP数据报长度的16bit位数决定的。去除20byteIP数据报首部、8byteUDP数据报首部，UDP数据报中用户数据长度最大为65507byte。大多数应用程序提供的实现长度小于65507byte。

##### 1 发送数据报的长度限制
发送UDP数据报长度的限制来源于两个方面：<br>
**[1] 应用程序受到其程序接口限制** socket API为用户提供一个可供程序调用的函数，用于设置接收和发送缓存的长度。对于UDP，该收发缓存的长度和最大UDP数据报长度直接相关。

**[2] TCP/IP内核实现的限制** 内核实现过程中可能设计了一些特性，使得IP数据报最大收发长度小于65535byte。对于chapter1中提供的通用网络主机结构中部分系统，测试其收发UDP数据报(封装在IP中)最大长度如下所示。<br>
**#1** SunOS 4.1.3系统环回接口的IP数据报收发的最大长度为32767byte。<br>
**#2** Solaris 2.2系统环回接口的IP数据报最大长度为65535byte。<br>
**#3** BSD/386 -> SunOS 4.1.3的IP数据报最大长度为32786byte。<br>
**#4** Solaris 2.2 -> Aix 3.2.2的IP数据报最大长度为65535byte。<br>
由此可以推断，不同系统内核实现会影响最大发送数据报的长度；最大数据报长度和远端以及目的端都相关。

**[3] 应用程序内部实现限制** 许多应用程序设计中，要求应用程序收发的数据最大大小为512byte甚至更小。如：chapter10中的选路信息协议RIP，将选路路由信息条目数量限制为25个，因此其总长度为504byte不会超过512byte。在后续章节部分知识内容中，其他UDP的应用程序如DNS、TFTP、BOOTP、SNMP都会设计到最大数据长度限制。

##### 2 应用程序读取数据报的长度限制 
对于IP层能够接受特定长度数据报，但是这不意味应用程序100%能够读取该长度的数据报。UDP编程接口允许应用程序指定每次返回的最大字节数，如果接收到的数据报长度大于应用程序内部实现能够处理的长度，则针对该数据报的处理方式取决于编程接口的具体实现。

对于数据报长度大于程序内部实现能处理的长度时，几种典型的系统处理方式如下：<br>
**(i)** Berkelay版socket API将多余的数据报进行截断，然后丢弃多余的数据。**(ii)** svr4系统下的socket API并不会截断数据报，而是对于超出长度的数据报进行多次读取，并且不会通知应用程序从单个UDP数据报中进行了多次读取操作。

### ICMP源站抑制差错
当一个系统(router & host)接收数据报的速度比其处理速度要快时，**可能**产生ICMP源站抑制差错。需要注意的是：即使一个系统接受缓存已经用完，也不会强制它发送源站抑制报文。

##### 1 源站抑制ICMP报文格式
<center><img src="/img/in-post/tcp-ip_img/udp_20.pdf" width="60%"></center>

##### 2 产生ICMP源站抑制报文(案例)
使用chapter1中的通用主机网络结构中的一部分，并利用它产生ICMP差错报文：从bsdi主机通过sun路由器向solaris主机发送100份1024byte长度的数据报。<br>
bsdi主机通过以太网连接到sun主机，sun主机通过SLIP线路连接到netb主机，由于以太网的数据传递速率远远大于SLIP线路速率，因此sun主机的发送端缓存很快就会用完，导致其返回给源端bsdi主机ICMP源站抑制报文。<br>
具体地，在bsdi主机上运行："bsdi %sock -u -i -w1024 -n100 solaris dicard"以产生用于堵塞sun主机发送缓存的数据报。

##### 3 理论计算对于案例进行分析
根据[chapter-2串行线路吞吐量计算](http://localhost:4000/tcp-ip/2021/08/04/post-tcp-ip-link-layer/#关于串行线路吞吐量的计算)可知：以9600bit/s的传输速率传输1024byte需要大约使用1066ms≈1s能够传输完成。考虑到sun主机发送到netb的SLIP线路的MTU=552byte，因此其实际传输时间可能会更长一些。<br>
sun主机处理收到的数据报的速度很快，只需要不到1s就可以处理至少142份数据报(根据下面tcpdump程序转包结果时间很容易得出)。100份长度为1024字节的数据处理完成，第一份IP数据报尚未通过SLIP线路，因此sun的发送端缓存被用完是不足为奇的。

##### 4 ICMP源站抑制案例设计的主机网络拓扑图
<center><img src="/img/in-post/tcp-ip_img/udp_21.pdf" width="60%"></center>

##### 5 使用tcpdump程序抓包用于分析源站抑制数据报发生机制
<center><img src="/img/in-post/tcp-ip_img/udp_22.pdf" width="100%"></center>

##### 6 关于ICMP源站抑制机制补充说明
**[1] 关于是否应当使用源站抑制机制** <br>
RFC-1009要求路由器在用光缓存时产生源站抑制数据报，但是新版的Router Requirements RFC[Almquist 1993]指出路由器不应当产生ICMP源站抑制报文，主要的观点在于：ICMP源站抑制报文将会极大的占用传输带宽(本案例中每发送一份UDP数据报就会同时发送一份ICMP源站抑制报文)，因此对于使用ICMP源站抑制机制是不支持的。

**[2] 关于ICMP源站抑制机制是否一定起作用** <br>
结合本案例分析，sock程序要么没有收到sun主机返回的源站抑制报文，要么收到抑制报文后将它们忽略了。根据tcpdump打印的时间可以很容易得出结论：sock程序发送100份1024长度的数据报只需要0.5s的时间，而第一份ICMP源站抑制报文在0.71s才返回，因此sock进程已经终止，此ICMP源站抑制报文根本无法通知到到相关进程。<br>
因此，即使采用了ICMP源站抑制机制也不一定能够保证它能通知到源端进程，对于源端数据发送进行指导。

**[3] UDP是一个不可靠协议** <br>
结合tcpdump命令输出结果分析，发出的100个UDP数据报只有26份成功到达目的端，剩余的74份数据报很有可能被中间路由器丢弃。除非在应用程序层面建立应答机制，否则UDP不能保证通知发送端数据是否到达，即发送端不知道接收端是否收到数据。

### UDP服务程序设计
UDP服务程序的设计和UDP实现有着密不可分的关系。<br>
通常情况下，客户端的设计比服务端的设计要容易的多，这也是本部分内容讨论服务端而不是客户端设计的原因。服务端程序不仅要处理和操作系统之间的交互，还需具备同时处理多个客户端请求的能力。

单个客户端程序启动后直接和单个服务器进行通信，完成任务后直接关闭自身程序即可。但是服务端程序启动时处于休眠状态(等待客户请求的到来)，当客户端UDP数据报到达时，服务端程序转变为苏醒状态，并处理包含在UDP数据报中客户端的请求。

本部分内容关注的不是UDP服务程序编程相关的内容，而是UDP的哪些特性会影响到UDP服务程序的设计和实现特性。

##### 1 客户端IP地址和端口号 
UDP客户端向UDP服务端发送UDP数据报。封装UDP数据报的IP数据报首部包含源端IP地址、目的端IP地址。被封装的UDP数据报首部包含源端端口号、目的端端口号。<br>
UDP客户端报文中包含的源端IP地址、端口号信息时非常重要的，该信息允许了服务端程序能够处理多个客户(能够区分并给予每个客户程序以应答)。

##### 2 目的端IP地址
部分应用程序需要知道UDP数据报时发送的目的端信息。例如：TFTP服务器设计为"必须忽略收到的广播数据报"，即TFTP服务器必须获取收到数据报的目的地址，以确定是否为广播形式发送的数据报，并决定是否丢弃。<br>
应用程序获取目的IP地址信息需要系统提供支持：操作系统从接收到的UDP数据报中提取目的IP地址并传给应用程序；并不是每个系统都支持该功能。<br>
socket API提供了在IP_RECVDSTADDR选项提供了该功能。在chapter1中通用主机网络结果中，BSD/386、4.4BSD、AIX 3.2.2支持该功能，但SVR4、SunOS 4.x、Solaris 2.x都不支持该选项。

##### 3 UDP输入队列
大多数UDP服务器是交互式服务器，因此单个服务器继承对单个UDP端口上的所有客户请求进行处理。每个UDP端口有一个有限大小的输入队列，不同客户的发送给UDP端的请求将由UDP自动排队，并按照FIFO的顺序进行处理并输出；ARP处理输入输出的方式是LIFO。需要注意的是：应用程序不知道输入队列何时发生溢出，UDP将会对溢出的用户请求部分做丢弃处理，并且UDP并不会通知应用程序该请求数据报被丢弃。

##### 4 socket程序通过选项限制本地IP地址(Local Address)
**[1] 指定端口号并启动一个UDP服务程序 & 使用netstat命令观察端口状态** <br>
仅使用端口选项创建的socket服务程序，只要接收到的UDP数据报目的为socket程序占用的端口，则在任意一个本地物理接口都可以接受它。
<center><img src="/img/in-post/tcp-ip_img/udp_23.pdf" width="100%"></center>
**[2] 指定IP地址(可以是本地IP地址包括本地广播地址)&端口号启动一个UDP服务程序 & 使用netstat命令观察端口状态** <br>
使用IP地址和端口号共同启动UDP服务程序时，接收到的UDP数据报目的IP地址和指定IP地址匹配，该数据报才能被送到相应应用程序(按照端口进行匹配)。
<center><img src="/img/in-post/tcp-ip_img/udp_24.pdf" width="100%"></center>
**[3] 在sun主机上的同一个端口号启动不同的5个UDP服务应用程序 \<A\>选项用于告诉系统允许端口号重用** <br>
UDP数据报按照IP地址进行匹配后发送到指定应用程序(端口)，其中目的IP地址和源IP地址匹配的过程存在一定优先级。有精确匹配优先考虑，其次才匹配带有"\*"的端点。
<center><img src="/img/in-post/tcp-ip_img/udp_25.pdf" width="100%"></center>

##### 5 socket程序通过选项限制远端IP地址(Foreign Address)
第4部分限制近段IP地址中netstat输出结果中，远端IP和远端端口号都显示为"\*\.\*"，表明该UDP服务程序端口能够接受来自任何IP地址、任何端口号的UDP数据报。<br>
socket程序可以使用\<f\>选项来指定远端IP&端口号，以限定服务程序能够接受的数据报的来源范围。程序运行&netstat打印输出的结果如下图。
<center><img src="/img/in-post/tcp-ip_img/udp_26.pdf" width="100%"></center>

socket命令指定了远端端口号，但是netstat命令显示近端端口号也被设置了。这是BSD派生系统在设置远端IP&端口时带来的副作用：如果指定远端Ip地址&端口时，本地IP地址尚未设置，那么将自动选择IP地址。

UDP服务程序能够接受的3种"本地-远端IP&端口号"限制的数据报 <br>
需要注意的是，下图中三种本地远端接受的数据报接受限制具有接受优先级。即如果一份收到的IP数据报同时满足上述3项限制，那么该数据报将按照从上自下的优先级进行匹配。
<center><img src="/img/in-post/tcp-ip_img/udp_27.pdf" width="60%"></center>

##### 6 每个端口可以存在多个接受服务程序
RFC没有明确指明，但是大多数系统在同一时刻只允许一个应用程序和指定的IP地址&端口号相关联。

**[1] 在sun主机上尝试在特定IP地址&端口上绑定两个不同的UDP服务程序 "addr already in use"**
<center><img src="/img/in-post/tcp-ip_img/udp_28.pdf" width="100%"></center>

**[2] 支持多播的系统上不同的应用程序可以占用相同的IP地址和端口号(设置SO_REUSEADDR标志位)** <br>
多个应用程序共享单个IP地址&端口号可以按照下面2种情况进行分析：<br>
**(i)** 当UDP数据报目的IP地址为广播地址或者多播地址，但同时存在多个应用程序在监听目的地址&端口号，则像每个监听的应用程序都发送一份UDP数据报的copy。<br>
**(ii)** 当UDP数据报的目的地址是一个单播地址，虽然改地址同时有多个监听的应用程序，但是只向其中某个应用程序发送UDP数据报的copy，具体选择哪个程序进行发送取决于系统的实现。

在我们构建的chapter1主机网络通用结构中，4.4 BSD系统支持多播，每个应用程序设置"SO_REUSEADDR"标志位即可允许多个应用程序共享相同IP的同一个端口。<br>

## Reference
> \<tcp-ip: illustrated vol1\> chapter11 <br>

> 1 当使用inline数学公式且公式经过GFM排版之后都在同一行 使用`$...$`符号<br>
> 2 当希望数学公式单独成行或者经过GFM排版之后占用多行 应当使用`$$...$$`符号<br>
> 3 对于表示条件概率 需要表示竖线的时候`|` 应当使用`\mid` 而不是直接在键盘上打出`|` => 容易被编辑器认为是一个md制表符<br>
> 4 在md引入图片的时候 不要使用`<center>`和`</center>` 在这篇文档的编辑过程中vscode的preview插件在使用了上述符号之后 导致下一段的数学公式预览显示不正常<br>
> 5 使用md的时候 单独的两段文字上下需要空出一行<br>
> 6 想要强制换行的时候 需要使用`<br>`而不是`<enter>`<br>
> 7 特殊字符如果想要避免和md解析关键字冲突 应当使用``将关键字包含在内 <br>
> 8 `<center><img src="/img/in-post/economics_4/xxx.png" width="60%"></center>` <br>
> 9 使用html设置图片文字环绕方式: <br>
    `<div>` <br>
        `<img src="/img_path" align="left" width="40%" hspace="" vspace=""/>` <br>
        `<p>paragraph1 around the picture</p>` <br>
        `<p>paragraph2 around the picture</p>` <br>
        `<p>paragraph3 around the picture</p>` <br>
    `</div>` <br>
> 10 `<font style="color:red; font-weight:bold">加粗蓝色</font>`用来设置字体颜色 <br>
> 问题脚注: ### ???problem😫problem???
