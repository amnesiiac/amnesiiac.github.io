---
layout: post
title: "makefile - #13"
subtitle: '[跟我一起写makefile - 陈皓]' 
author: "twistfatezz"
header-style: text
# header-img: "img/in-post/economics_1/headimg.png"
# header-mask: 0.8
comments: false 
mathjax: false 
date: 2022-01-05 08:54
lang: ch 
catalog: true 
categories: makefile
tags:
  - Time 2022
---
## make的隐式规则(第二篇)
**隐式规则的应用场景** 在Makefile中重编译目标文件所需要的标准流程化的规则在很多场合都会用到。例如：根据.c源文件创建对应的.o文件；一种较为传统的方式是借助GNU c compiler根据源文件(.c)创建目标文件(.o)。

**隐式规则的作用** "隐式规则"机制为make提供了一种重编译某类型目标文件的❮隐式❯方法，从而不需要在Makefile中❮显式❯给出重编译特定目标文件所需的细节规则描述。例如：隐式规则可以自动地将后缀名为.c的源文件编译成后缀为.o的目标文件。

**make根据实际需要可支持同时应用多个隐式规则** 例如：make可以先将一个.y后缀的文件生成对应的.c文件，然后再次应用隐式规则将.c后缀文件生成最终的.o文件。<br>
即只要目标文件名中除了后缀名不同，其他部分都相同，则make可以使用若干隐式规则来最终生成这个文件(只要原始.y文件存在)。

**隐式规则执行的控制** 内嵌的隐式规则在在相关的规则定义中会用到一些变量(通常为内嵌变量)，因此可以通过修改这些变量的定义来控制隐式规则命令执行的情况。例如：内嵌变量CFLAGS表示了gcc编译器编译源文件的编译选项，我们可以通过重定义CFLAGS以改变编译源文件所使用的选项参数。

**使用模式规则、后缀规则来定义隐式规则** 尽管不能直接改变make内嵌的隐式规则，但是可以使用模式规则(pattern rules)来重新定义自己的隐式规则。后缀规则(suffix rules)是定义隐式规则的另一种more limited的方式。模式规则更加通用、清晰，但是为了兼容性保留了后缀规则。


### 五：模式规则
模式规则和普通规则类似，不同之处只在于模式规则中，目标名需要包含模式字符"%"。例如，模式规则"%.o : %.c"表示所有的.o后缀文件依赖于对应的.c后缀文件。我们可以使用模式规则来定义隐含规则。

使用模式规则需要注意：模式字符"%"的匹配和替换发生在所有变量、函数展开后。变量、函数的展开一般发生在make读取Makefile时，而模式字符的匹配、替换一般发生在make执行时。

##### 1 模式规则介绍
模式规则中，目标文件名含有模式字符"%"的文件，其中模式字符"%"可以匹配❮任何非空❯的字符串。例如，"%.c"可以匹配任何.c后缀结尾的文件，"s%.c"可以匹配任何以s开头，以.c后缀结尾的文件；假设用于匹配的文件名长度至少3个字符，则"s%.c"可以匹配文件名至少为4个字符的文件。模式字符"%"至少需要匹配一个字符。

模式规则中，目标文件名中和"%"相对应的部分称为"茎(stem)"。所有能够匹配的文件名根据stem部分可以进行区分，也因此，匹配到的多个文件根据各自的stem部分根据隐式规则产生对应的依赖文件，该依赖文件必须是存在or可被创建的。

**[1] 第一种模式规则** 模式规则下的依赖规则格式为：
```txt
%.o : %.c
    COMMAND...
```
该模式规则指定根据"xxx.c"文件创建"xxx.o"文件，"xxx.c"文件应该为已存在的文件or可被创建的文件。

**[2] 第二种模式规则** 模式规则中的依赖文件可以不包含模式字符"%"，此时，模式规则的含义是：所有能够匹配目标模式的文件都依赖于一个指定的文件。例如：
```txt
%.o : debug.h
```
表示所有.o后缀的文件都依赖于头文件debug.h。

**[3] 第三种模式规则** 同一个模式规则可以存在多个目标。需要注意的是，多目标的模式规则和普通的多目标规则有些不同之处。<br>
普通的多目标规则的处理方式是：将每个目标作为一个独立的规则来处理，多个目标将对应多个独立的规则；这些规则有各自的命令行，不同规则的命令行可以相同。<br>
对于多目标的模式规则而言，所有的模式规则目标共同拥有依赖文件、规则的命令行；即当文件名符合多目标模式规则中任意一个目标模式时，规则定义的命令可能会执行。另外，由于多个目标共享模式规则的命令行，因此该命令行被执行一次后，规则不会去检查是否需要重建其他符合该模式的目标文件。

参考下面的案例进行理解：
```txt
# --- 变量定义 ---
Objects = foo.o bar.o
CFLAGS := -Wall

# --- 不带命令行的规则定义 -> 隐式规则的执行控制 ---
%.x : CFLAGS += -g
%.o : CFLAGS += -O2

# --- 多目标模式规则 ---
%.o %.x : %.c
    $(CC) $(CFLAGS) $< -o $@
```
在命令行中执行"make foo.o foo.x"，将会看到只有foo.o目标文件被成功创建，同时make将提示foo.x是最新的(实际上foo.x并没有被创建)。上述案例的结果表明：多目标模式规则在make处理时被作为一个整体来处理的，当对应foo.o目标文件的命令行被执行一次后，模式规则不会再检查其他符合该模式的目标文件(foo.x)的时间戳。<br>
如果将上述Makefile中的多目标模式规则部分替换成普通多目标文件规则，则规则对应的命令会执行2次，foo.o和foo.x目标文件都会被重建；这是因为普通目标规则下的每个目标文件都各自拥有独立的规则。

**关于模式规则的补充说明**
- ➀ 模式规则中的目多个目标模式在Makefile中的顺序需要注意，当一个目标文件同时符合多个目标模式时，make将把第一个模式规则目标对应的实例化规则作为重建规则；模式规则中其他的目标将被忽略。
- ➁ Makefile中显式指定的模式规则将会覆盖隐式规则。即当Makefile中出现一个对于特定目标文件可用的显式规则时，make将不会为这个目标寻找其他可用的隐式规则。Makefile中的显式规则的优先级永远高于隐式规则。
- ➂ 关于隐式规则中依赖文件的创建优先级：依赖文件存在or在Makefile中显式的提及的规则，要优先于哪些需要使用隐式规则来创建这些依赖文件的规则。

##### 2 模式规则示例
这一部分主要介绍几个模式规则示例，这些模式规则相应的隐式规则在GNU make中已经被预定义。

➤ 模式规则示例一：编译.c后缀文件到.o后缀文件的隐式模式规则如下：
```txt
%.o : %.c
    $(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
```
此规则描述了：.o后缀文件如何由对应的.c后缀文件创建。其中自动化变量"$<"表示依赖文件中的第一项("%.c")，"%.@"表示目标文件名("%.o")。

➤ 模式规则示例二：编译RCS目录下的.v后缀文件到同名任何格式文件的隐式模式规则如下：
```txt
# --- 双冒号规则 ---
% :: RCS/%.v
    $(CO) $(COFLAGS) $<
```
此规则描述了：任何文件"xxx.v"都可以由RCS目录下对应的"xxx.v"文件生成。规则中的目标文件"%"表明该规则可以匹配到任何文件，只要能够找到相应的依赖文件"RCS/%.v"。该规则为双冒号"::"规则，表明该规则是一个独立的最终规则，而不是类似普通规则作为中间补充规则；同时表明该模式规则的依赖文件不是中间过程文件。 

➤ 模式规则示例三：一个具有多个目标的隐式模式规则如下：
```txt
%.tab.c %.tab.h : %.y
    bison -d $<
```
该规则是一个多目标规则，该规则表明：调用命令"bison -d xxx.y"将会同时生成"xxx.tab.c"和"xxx.tab.h"。
多目标模式规则的一个具体的例子：
```txt
# --- 隐式模式规则依赖规则1 ---
$.tab.c $.tab.h : %.y
    bison -d $<

# --- 其他普通依赖规则2 ---
foo : parse.tab.o scan.o
scan.o : parse.tab.h

# --- 未显式给出的隐式依赖规则3 ---
parse.tab.o : parse.tab.c
scan.o : scan.c
```
在给定上述多个规则的场景下，当工程中parse.y文件被改变时，由于使用了多目标模式规则，只需要执行一次"bison -d parse.y"就可以重建所有相关依赖、目标文件(可以同时生成parse.tab.c和parse.tab.h)，即foo和scan.o文件的依赖项可以被一次性生成。

##### 3 模式规则中的自动化变量
模式规则中，规则目标文件、依赖文件(if包含模式字符)都代表了一类的文件，规则对应的命令是对所有匹配的文件重建过程的描述。显然，在模式规则对应的命令中，不能出现具体的文件名，针对不同的具体文件，规则命令中的重建过程也应该自动跟随。在规则对应命令中如何表示文件是本部分的主题。

自动化变量可以允许在命令中通过引用规则中文件的方式，来完成命令到模式规则的自动化匹配。自动化变量的取值是根据所在的规则中的目标文件、依赖文件名决定的。下面对于所有自动化变量进行说明：
- ➀ **$@** 表示规则的目标文件名。如果目标文件是一个文档文件(linux中一般称.a为文档文件(静态库文件))，则该变量表示文档文件的文件名。在多目标模式规则中，该变量表示那个触发规则命令执行的文件。
- ➁ **$%** 当规则的目标文件是一个静态库文件时，该变量表示静态库的一个成员名(member name)。例如，规则的目标为"foo.a(bar.o)"，则变量"$%"的值为bar.o，变量"$@"的值为foo.a。如果目标文件不是静态库文件，其值为空。
- ➂ **$<** 表示规则中依赖项的第一个依赖文件名。如果该目标文件使用隐式规则来创建，则该变量表示隐式规则加入的第一个依赖文件。
- ➃ **$?** 表示所有比目标文件时间戳更新的依赖文件列表，使用空格进行分隔。如果目标是一个静态库文件(archive member)，则该变量表示静态库文件的成员文件(.o文件，即member name)。<br>
补充：关于变量"$?"在显式规则中的作用。借助该变量("$?")，显式规则可以指定只对更新后的依赖文件进行操作，例如：静态库文件"libN.a"由一些.o后缀文件构成，使用如下规则：
```txt
lib : foo.o bar.o lose.o win.o
    ar r lib $?
```
上述Makefile实现了只将更新后的.o后缀文件加入到静态库lib中。
- ➄ **$^** 表示规则所有的依赖文件列表，使用空格分隔。如果目标文件是一个静态库文件(ar)，则该变量只能表示静态库文件的成员文件(.o文件，即member name)。一个文件可以在依赖列表中重复出现，但是变量"$^"只会记录该文件一次，即该变量会去掉重复的依赖文件。
- ➅ **$+** 该变量类似变量"$^"，但是它保留了依赖文件中重复出现的文件。该变量主要在程序链接时，涉及库的交叉引用的场合中被使用。
- ➆ **$\*** 在模式规则、静态模式规则中，代表"茎(stem)"所表示的部分，而stem为目标模式中"%"字符所表示的部分；当文件名中存在目录时，stem将需要额外包含目录部分("/"字符部分)。例如：文件"dir/a.foo.b"，当文件模式为"a.%.b"时，变量"$\*"的值为"dir/a.foo"(从"%"字符表示的部分到前面目录部分)。<br>
关于自动化变量"$\*"需要进行2点说明：
    - ➆-➀ 对于一个明确指定了文件名的规则而言，不存在stem部分，此时变量"$\*"的含义将发生改变：如果目标文件名带有一个❮可识别❯后缀，那么变量"$\*"表示文件中除了后缀之外的部分。例如：目标文件名为"foo.c"，则"$\*"的值为"foo"。GNU make对于这种目标文件对应的"$\*"变量处理方式是为了：和其他版本的make兼容性考量的；通常，在除静态规则、模式规则之外的显式指定目标文件的规则中，应当避免使用该变量。
    - ➆-➁ 对于一个明确指定了文件名的规则而言，如果该文件包含了❮不可识别❯的后缀时，此变量为空。

上面介绍的7个自动化变量，其中4个在规则中代表具体的文件名($@、$<、$%、$\*)，其余3个在规则中表示一个文件名列表。在GNU make中可以利用这7个个自动化变量获取完整文件名中的目录部分、具体文件名部分。

另外，在这些变量中加入"D"或者"F"字符即可形成一系列❮变种的自动化变量❯。这些变种的变量在旧版本的make中使用，对于新版本的make可以使用"dir"或"notdir"函数来实现相同的功能。下面列举这些变种的自动化变量如下：
- ➀ **$(@D)** 表示目标文件中的目录部分(不包含"/"字符)。如果"$@"为"dir/foo.o"，则变种变量"$(@D)"的值为"dir"。如果"$@"的值不包含"/"字符(不存在目录部分)，则变种变量"$(@D)"的值为"."。需要注意这个变种变量和函数dir的区别。
- ➁ **$(@F)** 表示目标文件的完整文件名中除目录之外的部分(实际文件名)。如果"$@"为"dir/foo.o"，那么"$(@F)"的值为"foo.o"。"$(@F)"变量的作用等价于函数"$(notdir $@)"。
- ➂ **$(\*D)、$(\*F)** 分别表示目标文件中"茎(stem)"中的目录部分和文件名部分。
- ➃ **$(%D)、$(%F)** 当以类似"archive(member)"形式的静态库为目标时，这两个变种变量分别表示库文件成员名中的目录部分和文件名部分。注意，这2个变种变量只对这种形式的规则目标有效。
- ➄ **$(<D)、$(<F)** 分别表示Makefile规则中第一个依赖文件的目录部分和文件名部分。
- ➅ **$(^D)、$(^F)** 分别表示Makefile规则中所有依赖文件的目录部分和文件名部分(重复文件只留存一份)。
- ➆ **$(+D)、$(+F)** 分别表示Makefile规则中所有依赖文件的目录部分和文件名部分(可存在重复文件)。
- ➇ **$(?D)、$(?F)** 分别表示时间戳较当前目标文件更新的依赖文件的目录部分和文件名部分。

➤ 关于自动化变量的书写形式：<br>
上述所有普通自动化变量都采用了"$标识字符"的形式，变种变量采用了"$(标识字符)"的形式。回忆Makefile中普通变量的引用方式："$(VARIABLE_NAME)"。普通自动化变量的引用风格和其他两个不同，如果为统一书写风格需要，也可以使用"$(标识字符)"的形式(e.g. "$<"等价于$(<))。

➤ GNU make中用于兼容Sysv版本make的特性：<br>
GNU make支持Sysv特性，即允许在Makefile中的规则依赖列表中使用如下三个特殊变量的引用(一般情况下，自动化变量只用于规则命令行中)："$$(@)"、"$$(@D)"、"$$(@F)"；它们分别表示"目标的完整文件名"、"目标文件名的目录部分"、"目标文件名中的实际文件名部分"；需要注意，这三个变量需要使用"$$"
而不是"$"。这三个自动化变量只能用于明确指定了目标文件名的规则中or静态模式规则中，不能用于隐式规则中。<br>
Sysv make和GNU make对于规则中的依赖项的处理方式不尽相同：Sysv make对于依赖项进行两次替换展开，而GNU make对于依赖列表只进行一次处理(变量、函数的引用被直接展开)。<br>
在使用GNU make时不需要使用此兼容性特性，也可以在Makefile中使用伪目标".POSIX"来禁用此特性。

##### 4 万用规则(match-anything pattern rules)
当模式规则中的目标名只包含一个模式字符"%"时，称这个模式规则为"万用规则"，即该规则目标可以是任何文件名。万用规则在构建Makefile时非常有用，但是它会影响到make的执行效率，因为make在执行时会尝试使用万用规则来重建其他规则中的目标、依赖文件。

➤ 考虑如下的例子对于Makefile中的万用规则进行理解：<br>
假如存在一个使用了万用规则的Makefile，该Makefile中的规则涉及了一个名为foo.c的文件。执行该Makefile时，为了创建foo.c文件，make将尝试使用下面几种方式(implicit rules)来创建该目标：
- ➀ 对于文件"foo.c.o"文件进行链接，以产生文件"foo.c"。
- ➁ 使用c语言的编译&链接：先从"foo.c.c"编译为"foo.c.o"，再链接生成"foo.c"文件。
- ➂ 使用Pascal程序的编译&链接：先从"foo.c.p"编译为"foo.c.o"，再链接生成"foo.c"。

显然上述的几种尝试路线是不必要的(不符合实际)，因为"foo.c"是一个c语言的源文件，而不是作为一个可执行程序。但make在执行时会试图根据所有可能的隐式规则来创建这个文件，只是由于上述3种路线的中间文件"foo.c.o"和"foo.c.c"不存在，导致这些"合成路线"被否定。<br>
但是，如果Makefile中存在一个万用规则，则make执行时需要考虑的"foo.c"文件的"合成路线"将会复杂的多：make将尝试根据万用规则来创建那些不能直接找到、不能通过其他显式规则创建的中间文件；从而导致make的执行效率大大降低。

➤ 为了避免使用万用规则导致的效率低下的问题，可以通过对万用规则加上限制的方式予以解决：<br>
- ➀ 将万用规则设置为最终规则，并使用双冒号方式进行定义。将其作为最终规则(仅当其依赖文件存在时才能被引用，即使它的依赖文件可由隐式规则创建也不行)。<br>
补充说明：非最终规则的万用规则不会被用于创建哪些符合某个明确模式规则的目标or依赖文件。即如果Makefile中存在匹配此文件的模式规则(非万用规则)，则该文件的重建只能由该模式规则而不是万用规则来完成。例如：文件"foo.c"，如果在Makefile中同时存在一个万用规则以及一个模式规则"%.c : %.y"；则"foo.c"文件的重建只能通过模式规则而不是万用规则。
- ➁ 通过定义一个内置的"哑模式规则"给出重建某一类文件的限制，从而避免使用非最终规则的万用规则。"哑模式规则"没有依赖项，也不包含命令行；该规则在make其他场景下会被忽略。例如：内置的"哑模式"规则"%.p :"为Pascal源程序文件"foo.p"指定了重建规则，从而避免了make试图寻找"foo.p.o"或"foo.p.c"的过程。

##### 5 重建内置的隐式规则
对于内置的隐式规则，可以在Makefile中对其进行显式重建以满足我们的需要。重建一个隐式规则时，规则部分需要使用和内置的规则相同的目标、依赖模式，命令部分可以根据需要进行自定义。通过这种方式可以替代有相同目标、依赖的make内置隐式规则；替代过的隐式规则在make执行时的调用顺序由它在Makefile中定义的位置决定。

例如，Makefile中包含了下面的一个规则：
```txt
%.o : %.c
    $(CC) $(CFLAGS) -D__DEBUG__ $< -o  $@
```
上面自定义的规则代替了make内置的从.o后缀文件编译生成.c后缀文件的隐式规则。

除了可以替代内置的隐式规则外，也可以通过指定空命令行来取消一个内置的隐式规则，如下所示：
```txt
%.o : %.c
```


### 六：缺省规则(defining last-resort default rules)
有些情况下，在make执行过程中无法为一个文件找到合适的重建规则(e.g. Makefile中没有给出重建它的明确规则，同时也没有合适、可用的隐式规则)，此时需要为make定义一个缺省的规则，来完成此类文件的重建。一言蔽之：当需要重建的目标文件没有可用的命令时，就执行这个缺省规则对应的命令。

##### 1 使用万用规则构建make的缺省规则
可以使用万用规则作为make的缺省规则。例如：在调试Makefile时(此时工程中部分源文件可能尚未编写完成)，但我们只关心Makefile是否能够正确执行，工程中源文件内容不是关注点(可使用源文件同名的空文件进行替代)。我们可以在Makefile中定义如下缺省规则：
```txt
# --- 借助万用规则 执行make时 对于所有不存在的文件(e.g. .o后缀文件)借助touch创建一个空的源文件 ---
% ::
    touch $@
```

##### 2 不使用万用规则，使用.DEFAULT伪目标构建缺省规则
➀ 上一节的例子可以使用.DEFAULT来实现：
```txt
.DEFAULT :
    touch $@
```
需要注意的是，不指定命令行的.DEFAULT规则的含义是：取消之前所有使用.DEFAULT方式指定的缺省执行命令：
```txt
.DEFAULT :
```
➁ 另外，可以给.DEFAULT伪目标规则指定一个❮空命令行❯，使其不执行任何命令(包括调用隐式规则命令)：
```txt
# --- 命令行使用[tab]字符开头 ---
.DEFAULT :
    
```
或者：
```txt
.DEFAULT : ;
```
更多关于Makefile中的空命令详见Reference中的文章。

➂ make的缺省规则也可以用来实现在一个Makefile中重载另一个Makefile。


### 七：旧风格的后缀规则(old fashioned suffix rules)
后缀规则是一种旧风格定义隐式规则的方式，在新版本的make中使用模式规则作为它的替代(模式规则在使用上比后缀规则要更加清晰)。现版本的make保留对其的支持的原因是向前兼容。

##### 1 后缀规则的类型
后缀规则有两种类型：双后缀规则(double-suffix rules)、单后缀规则(single-suffix rules)。<br>
➀ 双后缀规则定义了一对后缀：目标文件的后缀，以及相应依赖文件的后缀；该规则匹配所有后缀和目标文件后缀相同的文件。对于匹配到的一个目标文件，其依赖文件按照如下方式形成：将匹配的目标文件名中后缀依次替换为依赖文件中的后缀得到。例如：
```txt
# --- 双后缀规则中(目标文件.o 依赖文件后缀.c) 等价于下面的模式规则 ---
%o : %c
```
➁ 单后缀规则只定义一个后缀：源文件名的后缀；该规则匹配到任何文件。对于匹配到的文件，其依赖文件按照如下方式形成：将源文件后缀直接添加到目标文件名之后得到。例如：
```txt
# --- 单后缀规则中(源文件后缀.c) 等价于下面的模式规则 ---
% : %.c
```
➂ 单后缀规则还是双后缀规则的判断：如果规则中存在2个可被make识别的后缀，则为双后缀规则；存在1个可被make识别的后缀则为单后缀规则。参考下面的例子进行理解：<br>
.c和.o都是make可以识别的后缀，因此当定义了一个目标是.c.o的规则时，make将把它当作一个双后缀规则来处理：
```txt
.c.o :
    $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
```
等价于模式规则：
```txt
%.c : %.o
    $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
```

##### 2 书写后缀规则的注意事项
➀ 后缀规则中不存在任何依赖文件。否则，此规则将被作为一个普通规则对待，例如：
```txt
.c.o : foo.h
    $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
```
上述规则并不被当作一个后缀规则对待，而是一个目标文件为.c.o后缀、依赖文件为foo.h的普通规则。另外，这个规则也不等价于下面的规则：
```txt
%.o : %.c foo.h
    $(CC) -c $(CFLAGS) $(CPFLAGS) -o $@ $<
```
➁ 另外，需要注意的是，不带有命令行的后缀规则是没有任何意义的。这一点和不带有命令行的模式规则不同，在这里它不能取消之前使用后缀规则定义的规则。不带命令行的后缀规则作用仅仅是将这个meaningless的后缀规则添加到make中。

##### 3 通过维护.SUFFIXES特殊目标的值来修改make的"可识别后缀"
➀ 将特定后缀添加到make的"可识别后缀"列表中：
```txt
# --- 将.hack和.win后缀添加到make的可识别后缀列表的结尾 ---
.SUFFIXES: .hack .win
```
➁ 需要重设make默认的可识别后缀，则可以按如下方式实现：
```txt
# --- 清空所有已经定义的make可识别后缀列表 ---
.SUFFIXES:
# --- 重新定义用于后缀规则的make默认可识别后缀 ---
.SUFFIXES: .c .o .h
```
另外，make本身的命令行参数"-r"和"\-\-no-builtin-rules"同样可以清空所有已定义的可识别后缀。

➂ 关于变量SUFFIXES的说明：在make读取所有Makefile文件之前，变量SUFFIXES被定义为默认的可识别后缀列表。需要注意的是：即使存在这个变量，也不要通过修改SUFFIXES的值的方式来改变可识别后缀列表，应该借助修改特殊目标.SUFFIXES的依赖项来实现。


### 八：隐式规则的搜索算法(implicit rule search algorithm)
本小结内容介绍：make对于Makefile中的目标T的搜索隐式规则的算法。

##### 1 针对特定目标T的隐式规则搜索算法适用场景
- ➀ 不带任何命令行的双冒号规则。
- ➁ 不带任何命令行的普通规则。
- ➂ 不属于任何规则的目标项，但是作为某些规则的依赖项的文件。
- ➃ 在make的递归搜索隐式规则链的过程中，隐式规则链中每个中间规则的依赖项。

另外，在隐式规则的搜索过程中，不涉及后缀规则，因为所有的后缀规则都被转化成对应的模式规则。

##### 2 针对形式为archive(member)的目标的隐式规则搜索算法
对于形式为"archive(member)"的目标，下面的隐式规则搜索算法会执行两次：1) 首先按目标(T)为"archive(member)"进行搜索；2) 然后按照目标(T)为"member"再搜索一次。2次搜索的具体步骤为：
- ➀ 将目标(T)的目录部分分离，分离后目录部分称为D，其他部分称为N。例如，T="src/foo.o"，则有D="src/"，N="foo.o"。
- ➁ 列出所有和目标(T)，或者除目录部分(N)匹配的模式规则。如果模式规则中的目标包含斜杠"/"，则认为和目标(T)相匹配，否则认为和此模式规则和除目录部分(N)相匹配。
- ➂ ➁中得到的模式规则列表中，只要包含一个❮非万用规则❯，那么就将所有❮非最终万用规则❯删除。
- ➃ 删除➂中得到的模式规则列表中所有没有命令行的规则。
- ➄ 对于➃中得到的模式规则列表中的所有规则，执行：
    - (a) 获取模式规则中的"茎(stem)"部分(S)。S应该是目标(T)或除目录部分(N)中匹配模式字符(%)的非空部分。
    - (b) 获取依赖文件具体形式。将依赖文件中的模式字符(%)用(a)中得到的"茎(stem)"来替换。如果模式规则的目标模式(target pattern)不包含斜杠"/"，则把目录部分(D)加在每个"茎"替换完成后的依赖文件开头，构成完整的依赖文件名。
    - (c) 经过(b)中获得的依赖文件具体形式后，测试这些依赖文件是否存在，或者是否应该存在(ought to exist)。如果所有依赖文件都存在、应该存在，或者某些模式规则不存在依赖部分，则退出搜寻，应用所构建的模式规则。关于"应该存在"的含义：如果一个文件在Makefile中作为一个明确的目标，或依赖文件被提及，我们就说这个文件是一个"应该存在的文件"。
- ➅ 如果截止到➄，合适的隐式规则仍然没有找到，则执行进一步搜索。对于模式规则列表中的每一个规则：
    - (a) 如果该模式规则为"最终规则(terminal rule)"，忽略它，继续寻找下一条模式规则。
    - (b) 对于(a)中得到的模式规则，执行同➄-(a)/(b)一样的依赖文件具体化操作。
    - (c) 测试该模式规则的依赖文件是否存在、或者应该存在。
    - (d) 对于该模式规则中的在工程中不存在的依赖文件，递归调用本算法，以确定该依赖文件是否可由隐式规则来创建。
    - (e) 如果该模式规则的所有依赖文件都存在、应该存在、可以由一个隐式规则来创建，则退出查找，应用该规则。
- ➆ 如果找不到能够生成目标文件"archive(member)"的隐式规则，则指定特殊目标.DEFAULT所指定的命令(创建目标(T)，或者给出一个错误提示)。如果在Makefile中没有定义特殊目标.DEFAULT，则无法找到可用的命令来完成目标(T)的创建。退出make。

一旦使用上述算法找到了合适的模式规则，则对于每个目标模式(target pattern)，除了和目标(T)或除目录部分目标(N)相匹配的那个模式之外，其他目标模式中的模式字符"%"被替换成"茎(stem)"，并将替换结果文件名存储起来，直至目标文件remake命令被执行。

当目标对应的隐式规则被执行后，之前存储的文件名被录入make的数据库(database)，并被标记为"updated"状态(和目标(T)具有相同的update status)。

当上述算法找到的模式规则针对目标(T)执行时，自动化变量根据目标文件、依赖项的具体形式进行确定。


## Reference
> https://blog.csdn.net/haoel/article/details/2898 <br>
> GNU make zh/en chapter 10 <br>
> https://www.cnblogs.com/zxc2man/p/3759770.html - 双冒号规则 <br>
> https://blog.csdn.net/q_z_r_s/article/details/80783631 - 空命令

> 1 当使用inline数学公式且公式经过GFM排版之后都在同一行 使用`$...$`符号<br>
> 2 当希望数学公式单独成行或者经过GFM排版之后占用多行 应当使用`$$...$$`符号<br>
> 3 对于表示条件概率 需要表示竖线的时候`|` 应当使用`\mid` 而不是直接在键盘上打出`|` => 容易被编辑器认为是一个md制表符<br>
> 4 在md引入图片的时候 不要使用`<center>`和`</center>` 在这篇文档的编辑过程中vscode的preview插件在使用了上述符号之后 导致下一段的数学公式预览显示不正常<br>
> 5 使用md的时候 单独的两段文字上下需要空出一行<br>
> 6 想要强制换行的时候 需要使用`<br>`而不是`<enter>`<br>
> 7 特殊字符如果想要避免和md解析关键字冲突 应当使用\`\`将关键字包含在内 <br>
> 8 `<center><img src="/img/in-post/economics_4/xxx.png" width="60%"></center>` <br>
> 9 使用html设置图片文字环绕方式: <br>
    `<div>` <br>
        `<img src="/img_path" align="left" width="40%" hspace="" vspace=""/>` <br>
        `<p>paragraph1 around the picture</p>` <br>
        `<p>paragraph2 around the picture</p>` <br>
        `<p>paragraph3 around the picture</p>` <br>
    `</div>` <br>
> 10 `<font style="color:red; font-weight:bold">加粗蓝色</font>`用来设置字体颜色 <br>
> 问题脚注: ### ???problem😫problem???
