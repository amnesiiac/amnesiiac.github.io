---
layout: post
title: "assembly language (寄存器&内存访问)"
subtitle: '[assembly language wangshuang 3ed] - chapter3' 
author: "twistfatezz"
header-style: text
# header-img: "img/in-post/economics_1/headimg.png"
# header-mask: 0.8
comments: false 
mathjax: false 
date: 2022-01-17 15:19
lang: ch 
catalog: true 
categories: assembly
tags:
  - Time 2022
---
### 本文简介
在chapter2中，主要从指令执行的角度介绍了8086CPU的内部逻辑结构、形成物理地址的方式、指令执行相关的寄存器CS:IP、以及一些常用的指令。本章将从访问存储单元的角度介绍另外几个寄存器的相关内容。


### 一：内存中字的存储
在CPU中使用16-bit寄存器来存储1个字(word)：寄存器中high-8-bit用于存放字的高8位，寄存器low-8-bit用于存放字的低8位。由于1个word占用16-bit，因此1个字(word)需要占用2个存储单元，如下图：
<center><img src="/img/in-post/assembly_language_img/chapter_3_1.pdf" width="60%"></center>
- 单个字(word)的存储需要占用2个存储空间(2byte)：字型数据4E20H分别使用高、低地址单元存储高、低8-bit数据(4EH、20H)。
- 我们将存储单个字的两个地址连续存储单元构成的16-bit存储空间称为"字单元"，并将起始地址为N的"字单元"称为"N字单元"：起始地址为20000H的连续2个存储单元和在一起称为20000H字单元。


### 二：DS和[address]
CPU要读写某个存储单元时，必须先给出这个内存单元的地址；在8086CPU中，内存地址由段地址、偏移地址构成。8086CPU中有个称为DS的段寄存器，通常用来存放待访问数据的段地址。

例如，要读取物理地址为10000H处的存储单元中的内容，可按如下的程序段进行：
```txt
# 将物理地址为10000H(1000:0)的存储单元中的数据读取到寄存器AL中
mov bx,1000H # 将段地址1000H存放在通用寄存器bx中
mov ds,bx    # 使用通用寄存器bx给ds段寄存器赋值
mov al,[0]   # 将一个存储单元中的数据赋值给8-bit通用寄存器AL 存储单元的物理地址为DS:0
```

➤ 关于MOV指令的用法整理：<br>
- ➀ 将数据直接送入指定寄存器中。例如："mov ax,0123H"指令将0123H数据送入通用寄存器AX中。
- ➁ 将一个寄存器中的内容赋值给另一个寄存器中。例如："mov ax,bx"指令将通用寄存器BX中的数据送入通用寄存器AX中。
- ➂ 将一个存储单元中的数据送入一个寄存器中。例如："mov al,[偏移地址]"指令将把"DS:偏移地址"计算得到的物理地址对应的存储单元中的数据送入低8-bit通用寄存器AL。

➤ 于是，想要读取物理地址为10000H的存储单元中的数据，需要经过如下步骤：<br>
- ➀ 首先需要设置段地址:偏移地址，其中段地址为1000H，由于8086CPU不支持直接为段寄存器DS赋值，所以先将数值传递给BX，再通过寄存器间赋值将值传给DS；
- ➁ 然后使用MOV指令➂用法，将指定物理地址中的数据送入目标寄存器AL：注意此时只需要通过"[偏移地址]"即可得到目标地址的数据，因为CPU默认从DS寄存器中的读取段地址。

➤ 上述代码案例中为什么不能直接为DS段寄存器赋值，而是需要通过BX寄存器来实现赋值？<br>
答：8086CPU不支持直接使用数据为DS段寄存器赋值。


### 三：字(word)型数据的传输
8086CPU为16-bit结构，数据总线为16-bit结构，可以传输16-bit数据，即单次可以传输1个字(word)。借助MOV指令可以实现在寄存器、存储单元之间进行字(word=2byte)的传输。

➤ 给定汇编代码段和相应存储单元存储的数值，逐步分析汇编指令执行情况：<br>
<center><img src="/img/in-post/assembly_language_img/chapter_3_2.pdf" width="60%"></center>
```txt
mov ax,1000H  # 将段地址1000H送入通用寄存器AX中 
mov ds,ax     # 通过MOV指令借助AX寄存器给段寄存器DS赋值
mov ax,[0]    # 将1000H:0物理地址对应存储单元中的数值送入通用AX寄存器
mov bx,[2]    # 将1000H:2物理地址对应存储单元中的数值送入通用BX寄存器
mov cx,[1]    # 将1000H:1物理地址对应存储单元中的数值送入通用CX寄存器
add bx,[1]    # 将1000H:1物理地址对应存储单元中的数值和BX中的数值相加，结果送入通用BX寄存器
add cx,[2]    # 将1000H:2物理地址对应存储单元中的数值和CX中的数值相加，结果送入通用CX寄存器
```
根据上述汇编代码及相关存储单元存储数值情况，对于代码执行后的寄存器数值结果、分析如下表：
<center><img src="/img/in-post/assembly_language_img/chapter_3_3.pdf" width="70%"></center>


### 四：MOV、ADD、SUB指令
本文之前的部分介绍了MOV、ADD、SUB指令，它们带有2个操作对象，其汇编指令书写形式分别如下各表所示：
<center><img src="/img/in-post/assembly_language_img/chapter_3_4.pdf" width="100%"></center>


### 五：数据段
对于8086CPU，可以根据需要将一段存储单元定义为一个段；例如：我们可以将一段长度为N(N<=64kb)、地址连续、起始地址为16的倍数的存储单元作为专门存储数据的存储空间，从而定义了一个数据段(12B0H~123B9H这段内存是一个数据段，段地址12B0H，长度为10b)。

关于如何操作一个数据段的存储单元中的数据，结合下面的例子进行理解：将12B0H~123B9H的存储单元定义为一个数据段，想要编写汇编代码累加这个数据段中前三个数据，代码如下：
```txt
mov ax,123BH  # 将段地址123BH送入通用寄存器ax
mov ds,ax     # 将通用寄存器中的段地址送入段寄存器ds中
mov al,0      # 使用al存放累加结果
add al,[0]    # 将ds:0物理地址对应的存储单元中的数据累加到al中
add al,[1]    # 将ds:1物理地址对应的存储单元中的数据累加到al中
add al,[2]    # 将ds:2物理地址对应的存储单元中的数据累加到al中
```


### 六：栈
不同于之前使用的线性存储空间，栈是一种具有特殊访问方式的存储空间(或者说是对于线性存储空间的"栈型"管理)，它的特殊性在于：最后进入栈空间的数据，最先出栈。

对于栈型存储空间的管理，从程式化的角度需要维护一个一直指向栈空间顶端的标记。关于数据存入栈空间以及从栈空间取出数据，提供了两个基本操作：入栈、出栈；入栈是将一个新的元素放到栈顶，出栈是将栈顶元素推出。栈型空间的这种读写数据的模式被称为"LIFO(last in first out)"。


### 七：CPU提供的栈机制
8086CPU中也支持栈型存储空间，它提供相关汇编指令来按照"栈的方式"访问存储空间；即在基于8086CPU编程时，可以将一段存储空间当作栈来使用。

8086CPU提供了入栈、出栈指令：PUSH、POP；例如，"push ax"表示将寄存器ax中的数值送入栈空间中，"pop ax"表示从栈顶取出数据送入ax寄存器。需要注意的是，8086CPU在执行栈操作时，是以字(word)为单位进行的。

➤ 对于一段给定的栈型存储空间(10000H~1000FH)，结合下图理解PUSH、POP指令对于栈型空间的操作：<br>
<center><img src="/img/in-post/assembly_language_img/chapter_3_5.pdf" width="70%"></center>
注意，在栈型空间的PUSH、POP操作按照字(word)为单位进行，其中高地址存储单元存放字的high-8-bit，低地址存储单元存放字的low-8-bit。

➤ 结合上面对于栈型存储空间的操作，有几个问题需要解释：<br>
- ➀ 在上面的案例中，将10000H~1000FH的存储空间按照栈的LIFO规则进行访问，那么CPU是如何知道10000H~1000FH这段存储空间当作栈空间来使用呢？<br>
- [answer for ➀] 这个问题的解答涉及到CPU中对于一段存储单元的用途的界定方式：我们可以将一段存储单元定义为数据段(用来存放数据)，此时需要将段地址送入DS段寄存器中(标定数据段的起始地址)，将偏移地址以"[xxx]"的形式标记；我们也可以将一段存储单元定义为代码段(用来存放代码)，此时需要将段地址送入CS段寄存器(标定代码段的起始地址)，将偏移地址送入IP段寄存器(共同指向当前执行代码)。类似地，我们可以将一段存储单元定义为栈段，此时需要将段地址送入SS段寄存器(标定栈段的起始地址)，将偏移地址送入SP段寄存器以指向当前栈顶元素。<br>
综上，对于CPU中定义代码段、数据段、栈段的方式，可以统一归纳为：将相应的段寄存器、偏移地址设置完成后，CPU即将从❮起始地址❯到❮偏移地址指向的当前位置❯之间的存储单元看作是代码、数据、栈。
- ➁ 另外，当执行"push ax"等入栈指令执行时，要将寄存器的数据送入当前栈顶对应存储单元中，作为新的栈顶元素；当执行"pop ax"时，需要从栈顶取出数据送入AX寄存器中；那么在执行PUSH、POP操作时，是如何知道当前栈顶元素对应哪个存储空间呢？<br>
- [answer for ➁] 回忆CPU定位当前执行汇编代码位置时使用CS:IP段寄存器，CPU定位存储单元时使用DS:[偏移地址]的方式来完成；因此很容易想到，CPU用段寄存器SS:SP来定位当前栈顶在存储空间中的位置(任意时刻SS:SP指向当前栈顶元素)。

➤ 8086CPU对于PUSH指令的执行过程分析：<br>
<center><img src="/img/in-post/assembly_language_img/chapter_3_6.pdf" width="60%"></center>
从上面执行"push ax"指令的过程易知：在将AX寄存器中的数据压栈时，低8bit数据存放在栈段中物理地址较低的字存储单元中，高8bit数据存放在栈段中物理地址较高的字存储单元中；即AX寄存器中的低8bit优先送入存储单元，然后高8bit再送入存储单元。

➤ 8086CPU对于POP指令的执行过程分析：<br>
<center><img src="/img/in-post/assembly_language_img/chapter_3_7.pdf" width="60%"></center>

➤ 当栈段为空时，SS:SP指向何处？<br>
<center><img src="/img/in-post/assembly_language_img/chapter_3_8.pdf" width="60%"></center>
栈段的初始状态分析：将10000H~1000FH这段存储空间作为栈段，此时段地址应该由起始地址决定：SS=10000H/16=1000H；设定栈空间大小为16byte；栈底部字单元存储地址为1000:000EH。

栈段为空时，相当于将栈中唯一的元素执行出栈后的状态，根据8086CPU对于POP指令执行过程易知：SP=SP+2；由于任意时刻SS:SP指向栈顶，即当栈中剩余一个元素时，SS:SP指向栈地步字单元存储地址1000:000EH；综上，栈中最后的元素执行出栈后，SS:SP=1000:0010H。

换一种角度理解：任意时刻SS:SP指向栈顶元素，当栈为空时，栈中没有元素，因此不存在栈顶元素，此时SS:SP只能指向栈的最底部字单元的下一个单元：上述案例中栈最底部字单元的地址为1000:100EH，因此当栈空时，SS:SP指向1000:100EH+2H=1000:1010H。


### 八：栈顶溢出问题
根据本文上一部分的内容可知：8086CPU使用SS、SP寄存器来指示栈顶的地址，并使用PUSH、POP指令来实现入栈、出栈操作。既然SS:SP任意时刻总是指示栈顶的位置，那么如果向栈空间"PUSH"的元素太多，如何保证在入栈、出栈操作中，栈顶不会超过栈空间呢？

➤ 下图展示了执行PUSH指令后，栈顶元素超过栈空间的情况：<br>
<center><img src="/img/in-post/assembly_language_img/chapter_3_9.pdf" width="80%"></center>
将10010H~1001FH作为栈空间，该栈空间的容量为16b(8word)，初始状态为"栈空状态"；在执行8次"push ax"后，状态变为"栈满状态"；再次执行"push ax"后，SP=SP+2，此时SS:SP指向1000EH，任意时刻SS:SP指向栈顶，因此栈顶超过了栈空间，AX寄存器中的数据将栈空间外部的数据覆盖。

➤ 下图展示了执行POP指令后，栈顶元素超过栈空间的情况：<br>
<center><img src="/img/in-post/assembly_language_img/chapter_3_10.pdf" width="80%"></center>
将10010H~1001FH作为栈空间，该栈空间的容量为16b(8word)，初始状态为"栈满状态"；在执行8次"push ax"后，状态变为"栈空状态"；再次执行"pop ax"后，SP=SP-2，此时SS:SP指向10010H，任意时刻SS:SP指向栈顶，因此栈顶超过了栈空间，如果此后再执行"push"指令，栈外的存储空间(10020H~10021H)中的数据将会被错误的覆盖。

➤ 意外地使用栈外空间是非常危险的：<br>
栈顶越界是十分危险的，既然将一段存储空间作为栈空间，则栈外空间很有可能被用作程序的其他用途、或被其他程序所占用。如果在对栈空间进行操作时发生了栈顶越界问题，将栈空间之外的存储空间数据、代码改写，将导致发生一连串的错误。

我们希望CPU可以提供相应寄存器，用于记录栈空间上限、下限，并通过填写这些寄存器来指定栈空间范围，在CPU执行PUSH指令前检测栈空间上限寄存器，在执行POP指令前检查栈空间下限寄存器。但是，8086CPU不支持提供寄存器保存栈空间上下限，8086CPU只知道当前时刻栈顶在存储空间的那个单元上(SS:SP)，不知道我们安排的栈空间有多大。


### 九：栈型空间的push、pop操作
PUSH、POP是一对可以在寄存器和存储空间之间传送数据的指令。栈空间也是存储空间的的一种，它是一段以特殊方式进行访问的存储空间。

➤ PUSH、POP指令可以进行如下表所示的操作：<br>
<center><img src="/img/in-post/assembly_language_img/chapter_3_11.pdf" width="80%"></center>


### 十：栈段(栈型空间段)
在实际编程时，可根据实际需要，将一组内存单元定义为一个段，该段可以作为数据段、代码段、栈段等用途。需要注意的是，由于8086CPU中的偏移地址最多为16-bit，因此，定义的内存单元段的长度最大为64kb；另外，起始地址=段地址×16，因此存储单元段的起始地址必须为16的倍数。

将一段存储空间作为段来对待只是我们在编写汇编程序时的设计，8086CPU❮并不会❯因为这种设计在执行push、pop等栈操作时，自动将我们定义的栈段作为栈空间来处理(e.g. 自动检测push、pop栈操作是否出界)。8086CPU和我们设计的栈段唯一的"共识"是SS:SP始终指向栈顶存储空间的物理地址。


## Reference
> \<assembly language by wangshuang 3ed\> chapter3 <br>

> 1 当使用inline数学公式且公式经过GFM排版之后都在同一行 使用`$...$`符号<br>
> 2 当希望数学公式单独成行或者经过GFM排版之后占用多行 应当使用`$$...$$`符号<br>
> 3 对于表示条件概率 需要表示竖线的时候`|` 应当使用`\mid` 而不是直接在键盘上打出`|` => 容易被编辑器认为是一个md制表符<br>
> 4 在md引入图片的时候 不要使用`<center>`和`</center>` 在这篇文档的编辑过程中vscode的preview插件在使用了上述符号之后 导致下一段的数学公式预览显示不正常<br>
> 5 使用md的时候 单独的两段文字上下需要空出一行<br>
> 6 想要强制换行的时候 需要使用`<br>`而不是`<enter>`<br>
> 7 特殊字符如果想要避免和md解析关键字冲突 应当使用\`\`将关键字包含在内 <br>
> 8 `<center><img src="/img/in-post/economics_4/xxx.png" width="60%"></center>` <br>
> 9 使用html设置图片文字环绕方式: <br>
    `<div>` <br>
        `<img src="/img_path" align="left" width="40%" hspace="" vspace=""/>` <br>
        `<p>paragraph1 around the picture</p>` <br>
        `<p>paragraph2 around the picture</p>` <br>
        `<p>paragraph3 around the picture</p>` <br>
    `</div>` <br>
> 10 `<font style="color:red; font-weight:bold">加粗蓝色</font>`用来设置字体颜色 <br>
> 问题脚注: ### ???problem😫problem???
