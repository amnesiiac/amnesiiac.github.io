---
layout: post
title: "makefile - #14"
subtitle: '[跟我一起写makefile - 陈皓]' 
author: "twistfatezz"
header-style: text
# header-img: "img/in-post/economics_1/headimg.png"
# header-mask: 0.8
comments: false 
mathjax: false 
date: 2022-01-07 10:51
lang: ch 
catalog: true 
categories: makefile
tags:
  - Time 2022
---
## 使用make更新静态库文件
静态库文件也被称为"文档文件(archive files)"，它是一些.o后缀文件(member files)的集合，在Linux(unix)中使用工具"ar"对其进行维护管理。


### 一：静态库成员作为规则的目标项
一个静态库通常由多个.o后缀文件构成，这些成员(.o)可独立作为一个规则的目标。当静态库成员作为目标时，需要按如下格式进行书写：
```txt
# --- 表示静态库archive的成员文件member ---
archive(member)
```
上面的写法只能出现在规则的目标项、依赖项中，不能用在规则的命令行中。这是因为：绝大多数命令都不支持这种语法，规则命令不能直接对库成员进行操作。

##### 1 案例：创建静态库 & 将文件加入创建的库中
使用库成员构成的规则对应的命令只能是"ar"命令，或其他可以对库成员进行操作的命令。下面的命令用于创建静态库foolib，并将文件hack.o加入静态库foolib中：
```txt
foolib(hack.o) : hack.o
    ar cr foolib hack.o
```
实际上，上面规则的命令对于静态库foolib中的所有成员进行了更新，过程中使用了隐式规则创建需要的.o后缀文件。关于ar命令的用法可以参考ar命令的man手册。

##### 2 案例：在规则中同时指定静态库的多个成员
可以为规则制定多个静态库的成员，每个成员之间使用空格分隔，如下所示：
```txt
foolib(hack.o kludge.o)
```
也可以分别制定每个静态库的成员(等价的方式)：
```txt
foolib(hack.o) foolib(kludge.o)
```
另外，在为规则制定库中的成员时，可以使用shell通配符：
```txt
# --- 下面的规则表示静态库foolib中所有的.o后缀文件 ---
foolib(*.o)
```


### 二：静态库的更新
##### 1 静态库成员的更新
对于静态库的成员作为规则目标archive(member)时，make为其搜索隐式规则时，将同时考虑匹配archive(member)的隐式规则、以及匹配member的隐式规则。

目标项为"%"的万用规则能够与archive(member)进行匹配，该规则命令行将文件member复制到静态库archive中来更新目标archive(member)。例如：这种特殊类型规则可以通过复制(copy)文件bar.o到静态库foo.a中，以更新静态库成员foo.a(bar.o)。<br>
这种规则和其他隐式规则一并使用时，能够完成非常复杂的"自动生成规则目标的工作"，因此：
```txt
# --- shell命令行中执行make指令(使用引号""是为了避免成员括号被shell做特别解释) ---
make "foo.a(bar.o)"
```
即使Makefile为空、甚至不存在，也将导致如下的规则运行：
```txt
# --- bar.o文件本身在工程中不存在 但是合成目标需要它 因此它被当作一个中间文件生成 ---
# --- 使用cc命令编译bar.c生成源文件bar.o ---
cc -c bar.c -o bar.o
# --- 使用ar命令将文件bar.o加入到静态库foo.a中 ---
ar r foo.a bar.o
# --- 删除中间文件bar.o---
rm -f bar.o
```

对于一个静态库(文档文件)，其内部包含的成员(member)不含目录部分(directory name)；即使用"nm"命令查看静态库成员时，只能获取静态库成员名(一系列.o文件)，但是不包含目录。<br>
有时，为静态库成员显式指定目录部分可能是有益处的，例如：规则目标项可以写成：
```txt
# --- 显式为静态库foo.a的成员file.o指定目录部分dir/ ---
foo.a(dir/file.o)
```
当上述目标所在规则被执行时，可能会执行如下命令：
```txt
# --- 将带有目录部分的成员名加入静态库foo.a中 此时dir/file.o作为静态库的成员 ---
ar r foo.a dir/file.o
```
对于一个带有目录部分的目标文件的remake操作，涉及的隐式规则对应的命令行中可能需要使用如："%(D)"、"%(F)"等，或使用dir、notdir等函数进行修饰。

##### 2 更新静态库的索引符号表(update archive symbol directories)
本文前面的部分曾经提到，静态库文件需要使用"ar"命令来创建、维护；当需要给静态库增加一个成员时(增加一个.o后缀文件到静态库中)，使用"ar"命令可以直接将.o后缀文件增加到静态库的末尾。

➤ 增加.o后缀文件到静态库后可能出现的问题 <br>
当后续使用上述增加了一个.o后缀文件的静态库，执行链接并生成可执行文件时，链接程序ld可能会提示错误。导致产生错误的原因是：主程序使用了刚刚加入到静态库中的.o后缀文件中的函数、全局变量定义，但是链接程序ld无法找到该函数、全局变量定义。

➤ 出现上述问题的核心原因 <br>
之前在为静态库添加.o后缀文件时，直接将编译完成的.o后缀文件直接添加到库的末尾，但是没有更新静态库的❮有效符号表❯，因此，链接程序ld进行链接时，在静态库的符号索引表中无法定位到刚引入.o后缀文件中的函数、全局变量定义。想要在完成静态库追加.o文件后，使得.o文件中的函数、全局变量定义生效，则需要使用❮ranlib工具❯对静态库的符号索引表进行更新。

➤ 静态库中的特殊成员"\_\_.SYMDEF" <br>
静态库中存在一个特殊的成员"\_\_.SYMDEF"，它包含了静态库中所有成员文件中定义的有效符号(函数名、变量名)。因此，当为静态库增加一个.o成员文件时，需要更新特殊成员"\_\_.SYMDEF"，否则新添加的文件中的符号定义将无法被链接程序ld定位。

➤ 更新静态库的符号索引表"\_\_.SYMDEF" <br>
完成静态库符号索引表更新的命令是：
```txt
# --- ARCHIVEFILE表示需要更新符号索引表的静态库名称 --- 
ranlib ARCHIVEFILE
```
通常，在具体Makefile中可以按如下方式实现：
```txt
# --- 为静态库libfoo.a追加了两个.o文件 ---
libfoo.a : libfoo.a(x.o) libfoo.a(y.o) ...
# --- 使用ranlib命令为静态库更新符号索引表---
    ranlib libfoo.a
```
补充说明：如果我们在创建、管理维护静态库时，使用了"GNU ar"命令，则在更新静态库后，无需使用ranlib工具手动更新符号索引表。"GNU ar"程序在更新静态库时可以同时更新符号索引表(默认行为)。关于更多"GNU ar"程序的用法，详见相关man手册。


### 三：使用的静态库的注意事项
在make执行静态库文件目标相关规则时(更新静态库)，需要特别注意：make的并行执行(执行带有-j选项的make时)静态库文件相关规则时，可能会给静态库的更新带来不好的影响。因为在同一时刻，当出现多个并行的"ar"程序同时操作相同的静态库文件时，将会损坏静态库，甚至导致该静态库不可用。

在后续将发布的make版本中，可能会提供一种：将make并行操作同一静态库转化成序列化操作的机制；但是，目前版本而言，尚未提供此类型支持。因此，在书写Makefile时，需要认为控制对于静态库的更新操作策略，或者禁用掉make的并行执行功能。


### 四：静态库的后缀规则
对于静态库的remake操作也可以使用后缀规则。静态库的后缀规则属于后缀规则的特殊应用，后缀规则在现版本的make中已经被模式规则替代，由于make的向前兼容原因，现版本make仍然支持后缀规则。

为静态库文件编写后缀规则，只需要将目标后缀写成.a后缀(静态库常用的后缀格式)。可以参考下面的例子进行理解：
```txt
# --- 注意这个后缀规则的目标后缀被改写成.a ---
.c.a :
    # --- 使用cc命令将源文件编译成中间文件 ---
    $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
    # --- 使用GNU ar命令将中间文件追加到静态库中 ---
    $(AR) r $@ $*.o
    # --- 删除编译生成的中间文件 ---
    $(RM) $*.o
```
与上述后缀规则等价的模式规则为：
```txt
# --- 注意模式规则中目标文件模式为静态库的成员文件.o后缀 ---
(%.o) : %.c
    $(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o
    $(AR) r $@ $*.o
    $(RM) $*.o
```
可以看出：后缀规则中的.a后缀作为模式规则中的目标项的后缀，而后缀规则中的.c后缀作为模式规则中依赖项的后缀。<br>

##### 关于用于更新静态库文件的双后缀规则转化成的模式规则形式的说明
双后缀规则".xxx.a"被正常情况下，将被make转化成"(%.o) : %.xxx"。<br>
但是，这看起来稍微有点不那么直观，因为根据规律，双后缀规则".xxx.a"应该被转化成"%.a : %.xxx"，make支持这么做(内部仍然会按照前一种方式进行处理)。<br>
于是，用于更新静态库的双后缀规则可以被转化成两种形式的模式规则："(%.o) : %.xxx"以及"%.a : %.xxx"



## Reference
> https://haoel.blog.csdn.net/article/details/2899 <br>
> GNU make zh/en chapter 11 <br>

> 1 当使用inline数学公式且公式经过GFM排版之后都在同一行 使用`$...$`符号<br>
> 2 当希望数学公式单独成行或者经过GFM排版之后占用多行 应当使用`$$...$$`符号<br>
> 3 对于表示条件概率 需要表示竖线的时候`|` 应当使用`\mid` 而不是直接在键盘上打出`|` => 容易被编辑器认为是一个md制表符<br>
> 4 在md引入图片的时候 不要使用`<center>`和`</center>` 在这篇文档的编辑过程中vscode的preview插件在使用了上述符号之后 导致下一段的数学公式预览显示不正常<br>
> 5 使用md的时候 单独的两段文字上下需要空出一行<br>
> 6 想要强制换行的时候 需要使用`<br>`而不是`<enter>`<br>
> 7 特殊字符如果想要避免和md解析关键字冲突 应当使用\`\`将关键字包含在内 <br>
> 8 `<center><img src="/img/in-post/economics_4/xxx.png" width="60%"></center>` <br>
> 9 使用html设置图片文字环绕方式: <br>
    `<div>` <br>
        `<img src="/img_path" align="left" width="40%" hspace="" vspace=""/>` <br>
        `<p>paragraph1 around the picture</p>` <br>
        `<p>paragraph2 around the picture</p>` <br>
        `<p>paragraph3 around the picture</p>` <br>
    `</div>` <br>
> 10 `<font style="color:red; font-weight:bold">加粗蓝色</font>`用来设置字体颜色 <br>
> 问题脚注: ### ???problem😫problem???
