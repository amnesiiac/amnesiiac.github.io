---
layout: post
title: "assembly language (寄存器&执行指令)"
subtitle: '[assembly language wangshuang 3ed] - chapter2' 
author: "twistfatezz"
header-style: text
# header-img: "img/in-post/economics_1/headimg.png"
# header-mask: 0.8
comments: false 
mathjax: false 
date: 2022-01-11 21:50
lang: ch 
catalog: true 
categories: assembly
tags:
  - Time 2022
---
### 本文简介
一个典型的CPU由运算器、控制器、寄存器等器件组成，这些器件在CPU内部通过"内部总线"相连。回忆chapter-1中提到的总线，实际上为"外部总线"。"内部总线"实现了CPU内部各个芯片之间的连接，外部总线实现了CPU和主板上其他芯片之间的连接。

➤ CPU中各个组成部分之间的分工大致如下：
- ➀ 运算器进行信息处理。
- ➁ 寄存器进行信息存储。
- ➂ 控制器控制各种器件进行工作。
- ➃ 内部总线连接CPU内部各个器件，用于它们之间的数据传输。

对于一个汇编程序员而言，主要的职责是和CPU中的寄存器打交道：可以通过使用汇编指令对指定的寄存器进行读写，并通过修改CPU中各个寄存器的内容来实现对CPU的控制。

不同型号的CPU内部的内部的寄存器个数、结构是不同的。例如，8086有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。随着本系列知识整理，逐步进行介绍。


### 一：通用寄存器(AX、BX、CX、DX)
8086CPU的所有寄存器都是16bit的，可以存放2个字节。由于AX、BX、CX、DX这四个寄存器通常用于存放❮一般性数据❯，因此被称为"通用寄存器"。

➤ 8086CPU通用寄存器AX(16-bit)，其逻辑结构如下图所示：
<center><img src="/img/in-post/assembly_language_img/chapter_2_1.pdf" width="70%"></center>

➤ 8086CPU通用寄存器AX(16-bit)，其存储一个16-bit数据的情况如下图所示：
<center><img src="/img/in-post/assembly_language_img/chapter_2_2.pdf" width="100%"></center>

➤ 8086CPU通用寄存器AX(16-bit)，可以分成两个独立的8-bit寄存器来使用，8-bit寄存器的划分方式如下图所示：
<center><img src="/img/in-post/assembly_language_img/chapter_2_3.pdf" width="70%"></center>

[为什么8086支持将16-bit通用寄存器划分成两个8-bit寄存器?] <br>
8086CPU之前版本的CPU中的寄存器都是8-bit的，为了保证兼容性，使基于前面版本的汇编程序能够在8086CPU上运行，因此，8086CPU上的4个通用寄存器都可以分成独立的两个8-bit寄存器来使用。

➤ 8086CPU通用寄存器AX(16-bit)，分成两个独立的8-bit寄存器，存储一个16-bit数据的情况如下所示(每个独立的寄存器分别存储数据的高8bit、低8bit)：
<center><img src="/img/in-post/assembly_language_img/chapter_2_4.pdf" width="100%"></center>


### 二：字(byte)在寄存器中的存储
处于向前兼容性考虑，8086CPU可以一次性处理如下格式的数据：
- ➀ 字节(byte)：由8-bit组成，可以存储在8-bit寄存器中。
- ➁ 字(word)：由两个字节组成，分别称为高字节、低字节；相应的这两个字节分别存储在寄存器的高8-bit和低8-bit中。因而，对于16-bit整体寄存器进行访问可以得到字(word)数据，也可以单独访问高低8-bit寄存器以将其中的数据看成是独立的字节型数据。


### 三：基础汇编指令运行分析(mov/add)
➤ 通过汇编指令可以控制CPU执行指定任务，下表展示了基本汇编指令对于CPU中的寄存器的影响：
<center><img src="/img/in-post/assembly_language_img/chapter_2_5.pdf" width="80%"></center>
- 注意，在书写汇编语句、寄存器名称时，不区分大小写，例如："mov ax,18"和"MOV AX,18"的含义相同。

➤ 依次执行下表中的汇编指令，寄存器AX和BX中的数据变化如下表所示：
<center><img src="/img/in-post/assembly_language_img/chapter_2_6.pdf" width="80%"></center>
- 关于上表中程序段最后一条指令为什么是"044CH"：执行"add ax,bx"指令后，得到的结果本应该是1044CH，但由于通用寄存器AX只能存储16-bit数字，因此计算结果最高位1不能在AX中存储。

➤ 依次执行下表中的汇编指令，寄存器AX(AH+AL)和BX中的数据变化如下表所示：
<center><img src="/img/in-post/assembly_language_img/chapter_2_7.pdf" width="80%"></center>
- 关于上表中程序段最后一条指令执行后AX中的结果为什么是"0058H"：执行"add al,93H"指令后，得到的结果本应该是00158H，但是由于通用寄存器AL只能存储8-bit数字，因此计算结果最高位1不能在AL中存储。另外该"溢出位"也不能在AH寄存器中存储，这是因为汇编指令"add al,93H"不能操作AH寄存器中的数位。
- 如果上表中程序段最后一条指令改为"add ax,93H"，则CPU执行16-bit运算，即AX寄存器中的数据将变成0158H。


### 四：物理地址的概念
物理地址：当CPU访问内存存储单元时，需要给出内存单元的地址。所有内存单元构成的存储空间是一个一维线性空间[逻辑存储空间]，每个存储单元都有唯一地址，这个唯一地址被称为"物理地址"。

CPU通过地址总线将想要操作的内存单元对应的物理地址送入存储器。在CPU发送物理地址之前，首先需要在CPU内部形成该物理地址。不同的CPU形成物理地址的方式有所不同，本文后续部分将讨论8086CPU如何在内部形成内存单元物理地址。


### 五：16-bit结构CPU
在8086CPU之前的计算机(8080、8085)都是8-bit机器，而8086CPU是16-bit机器。16-bit机器指的是具有16-bit结构CPU的机器。

16-bit结构CPU主要具有如下的特性：
- ➀ CPU中的运算器一次性最多处理16-bit数据。
- ➁ CPU中的寄存器最大宽度是16-bit。 
- ➂ 寄存器和运算器之间的连接通路(内部总线)的宽度是16-bit。

➤ 16-bit结构的CPU单次操作(处理、传输、暂存)的数据宽度为16-bit：<br>
因此，具有16-bit结构CPU的8086计算器，其内部能够一次性处理、传输、暂时存储的信息最大长度为16-bit。进一步地，待操作的内存单元的地址在被CPU送上外部地址总线之前必须在CPU中处理、传输、暂存。


### 六：8086CPU形成物理地址的方法
➤ 8086CPU寻址能力分析：<br>
8086CPU的外部地址总线宽度为20-bit，因此它可以一次性传输20-bit地址，可以寻址的内存逻辑空间范围为1MB。另外，8086CPU是16-bit结构，在内部一次性处理、传输、暂存的地址为16-bit。总和考虑两个限制因素，8086CPU从内部只能发送16-bit地址，从而表现出的寻址能力为64kb。

8086CPU在内部使用两个16-bit地址总线共同传输地址的方式，来构成一个20-bit物理地址。

➤ 8086CPU相关部件的逻辑结构如下图所示(地址处理步骤如➀-➅)：<br>
<center><img src="/img/in-post/assembly_language_img/chapter_2_8.pdf" width="70%"></center>
- ➀ CPU中的相关部件提供了两个16-bit地址，一个称为"段地址"，另一个称为"偏移地址"。
- ➁ "段地址"和"偏移地址"通过内部总线送入一个称为地址加法器的部件。
- ➂ 地址加法器将两个16-bit地址合成为一个20-bit物理地址。
- ➃ 地址加法器通过内部总线将20-bit物理地址送达输入输出控制电路。
- ➄ 输入输出控制电路将20-bit物理地址送上地址总线。 
- ➅ 20-bit物理地址通过外部地址总线传输到存储器(内存)。

➤ CPU地址加法器使用两个16-bit地址来合成20-bit物理地址的方法：<br>
地址加法器使用"**物理地址=段地址×16+偏移地址**"的方式来合成物理地址。例如，8086CPU想要访问地址为123C8H的存储单元时，此时地址加法器的工作流程如下所示：
<center><img src="/img/in-post/assembly_language_img/chapter_2_9.pdf" width="80%"></center>

➤ 关于地址加法器计算物理地址时，将段地址×16的额外讨论：<br>
地址加法器在合成20-bit物理地址时，段地址×16的操作相当于：将16进制形式的段地址左移1位，或者将2进制形式的段地址左移4位。计算机中所有信息都以2进制的方式存储。关于2进制的移位和数据数值之间的关系，有如下规律：
- ➀ 一个数据的2进制形式表示如果右移1位，得到的新数据相当于"原数据×2"。
- ➁ 一个数据的2进制形式表示如果右移N位，得到的新数据相当于"原数据×2^N"。
- ➂ CPU内部地址加法器完成段地址×16的具体方式即：将段地址的2进制表示向右移动4位。


### 七："段地址×16+偏移地址=物理地址"的本质作用
地址加法器计算物理地址的算法的本质含义解析如下：CPU在访问内部存储时，使用一种"基础地址"+"一个相对基础地址的偏移地址"的形式，从而给出需要访问的存储单元的物理地址表示。对于8086CPU而言，基础地址的表示为"段地址×16"。

➤ 结合下面的例子，理解使用"基础地址+相对偏移地址"形式表示物理地址的意义：<br>
首先，给定学校、体育馆、图书馆的位置模型如下图所示，假设现在要去图书馆，有两种方式能够获取图书馆的位置信息：
- ➀ 从学校走2826m到达图书馆。2826m可以看成是图书馆的物理地址。
- ➁ 从学校走2000m到达体育馆，再从体育馆走826m到达图书馆。其中2000m可看成是基础地址，826m可看成是偏移地址。
<center><img src="/img/in-post/assembly_language_img/chapter_2_10.pdf" width="70%"></center>

然后，给定限制条件，有如下两种方式获取图书馆的位置信息：
- ➀ 通过一张只能书写下4-bit数字的纸条来获取图书馆位置信息。
- ➁ 通过两张只能书写下3-bit数字的纸条来获取图书馆位置信息。

最后，针对上述两种传递信息的限制条件，通知图书馆位置信息的两种对应方式如下图所示：
<center><img src="/img/in-post/assembly_language_img/chapter_2_11.pdf" width="90%"></center>

➤ 通过上述案例，可以总结8086CPU使用"段地址×16+偏移地址=物理地址"的地址表示法的实质作用在于：便于CPU使用多个内部较窄的地址总线(16-bit)来获取更宽的物理地址寻址范围(20-bit)。


### 八：段的概念
本文前一部分提到了"段地址"的概念，段地址本身是一个逻辑上的概念，而不是物理上的概念：实际上，内部(计算机内)存储单元并没有被划分成一个一个的段，每个段本身也不具有段地址。内部存储单元在物理上没有被分段，逻辑上的分段由CPU来完成，由于8086CPU使用"段地址×16+偏移地址=物理地址"的方式来表示内部存储单元的物理地址，从而方便CPU使用"分段"的方式来管理内存。

➤ CPU对于同一段存储单元，可进行任意的逻辑分段处理以管理这段内存。选取其中2种逻辑分段方式如下图所示：
<center><img src="/img/in-post/assembly_language_img/chapter_2_12.pdf" width="90%"></center>
- ➀ 根据编程需要，可以将连续的若干存储单元看作是一个段，用"段地址×16"作为段的起始地址，用偏移地址定位段中具体存储单元。
- ➁ 由于使用"段地址×16"的方式定位段的起始地址，因此一个段的❮起始地址❯一定是16倍数。
- ➂ 由于8086CPU内部地址总线为16-bit，因此偏移地址总线的宽度为16-bit，即段的最大长度为64kb。

➤ CPU对于同一存储单元对应的物理地址，可以使用不同的段地址、偏移地址予以表示：
<center><img src="/img/in-post/assembly_language_img/chapter_2_13.pdf" width="70%"></center>


### 九：段寄存器 - 用于存放段地址的寄存器
本前面部分提到：8086CPU在访问存储单元时需要由"相关部件"提供存储单元的段地址、偏移地址，然后再由地址加法器合成物理地址。"相关部件"指的是CPU中的段寄存器，8086CPU中有4个段寄存器：CS、DS、SS、ES。本文后续部分只介绍CS。


### 十：CS和IP
CS和IP是8086CPU中2个最关键的寄存器，它们指定了CPU当前需要读取的指令的地址。CS为代码段寄存器，IP为指令指针寄存器。

具体地，在8086CPU中，任意时刻如果CS中内容为M，IP中的内容为N，8086CPU将从位于"M×16+N"的存储单元读取相应指令并执行。换一种角度进行理解：在8086CPU中，任意时刻，CPU将CS:IP所指向的内容作为当前需要执行的命令。

➤ 8086CPU读取、执行命令涉及的相关部件结构示意图：
<center><img src="/img/in-post/assembly_language_img/chapter_2_14.pdf" width="80%"></center>
- ➀ 8086CPU中当前CS:IP状态：CS中内容为2000H，IP中内容为0000H。
- ➁ 物理地址为20000H～20009H的一段存储单元中存放可执行的机器码。机器码占用的存储空间及其对应的汇编指令如上图所示。

➤ 8086CPU读取、执行存储单元中第一条命令"mov ax,0123H"涉及的相关部件数据传输、处理流程示意图：
<center><img src="/img/in-post/assembly_language_img/chapter_2_15.pdf" width="90%"></center>
- 每读取一个存储单元中的数据，IP寄存器中的数值+1；因此由于第一条指令占用3byte，IP+=3，当指令"mov ax,0123H"完全进入指令缓存区后，IP寄存器中的数值更新为0003H。
- 后续存储单元中的各条指令的执行流程和本例类似，只是在指令相关数据全部读取至指令缓存区后，存放偏移地址的IP寄存器中的数值不同。

➤ 8086CPU读取、执行存储单元中第二条命令"mov bx,0003H"涉及的相关部件数据传输、处理流程示意图：
<center><img src="/img/in-post/assembly_language_img/chapter_2_16.pdf" width="90%"></center>
- 每读取一个存储单元中的数据，IP寄存器中的数值+1；因此由于第一条指令占用3byte，IP+=3，当指令"mov bx,0003H"完全进入指令缓存区后，IP寄存器中的数值更新为0006H。

➤ 8086CPU读取、执行存储单元中第三条命令"mov ax,bx"涉及的相关部件数据传输、处理流程示意图：
<center><img src="/img/in-post/assembly_language_img/chapter_2_17.pdf" width="90%"></center>
- 每读取一个存储单元中的数据，IP寄存器中的数值+1；因此由于第一条指令占用2byte，IP+=2，当指令"mov ax,bx"完全进入指令缓存区后，IP寄存器中的数值更新为0008H。

➤ 8086CPU读取、执行存储单元中第四条命令"add ax,bx" - (ditto, omitted)。

➤ 根据上面对于四条命令进行读取、传输、执行的CPU内部组件执行流程图的分析，可以总结得到8086CPU执行汇编命令的工作流程如下：
- ➀ 从CS:IP指向的存储单元中读取指令，读取的指令被送入CPU内部指令缓存区。
- ➁ IP=IP+读取的指令长度，以指向下一个将被执行的命令。
- ➂ CPU执行读取的指令，并跳转到➀，重复这个过程。

➤ 关于CS:IP的一些其他性质：
- ➀ 8086CPU加电启动后，或者复位后(CPU刚开始工作时)，CS和IP寄存器中的初始值将被设置成：CS=FFFFH、IP=0000H。因此，在CPU刚开始工作时，CPU默认从地址为FFFF0H的存储单元的指令开始执行。
- ➁ 在存储单元中，指令、普通数据之间没有任何区别，都是二进制信息；CPU在工作时，有时将存储单元中的信息看成是指令，有时将它们看成数据。那么，CPU根据什么来确定特定的存储空间中的信息是数据还是指令？<br> 
答：CPU将CS:IP中的内容看成是指令，并用CS:IP对应的段地址、偏移地址合成物理地址，以读取特定存储空间中的指令。换句话说，如果内存中的一段信息被CPU执行过，则它一定被CS:IP指向过。


### 十一：修改CS和IP的指令
在CPU中，程序员中能够通过指令读写的只有寄存器，程序员可以通过改变寄存器中内容来实现对CPU的控制；即程序员可以通过设置CS:IP中的数值来控制CPU执行指定的指令。

➤ 如何修改CS:IP的数值？使用MOV指令可行么？NO!!! <br>
回想本文前面部分介绍的指令，很容易想到MOV指令(传送指令)，我们可以通过类似"mov ax,xxx"来对于寄存器数值进行设置；MOV指令可以用于CPU中大部分寄存器数值的设置。然而，MOV指令不能用于设置CS:IP中数值，8086CPU没有提供此功能；但8086CPU提供了另外的指令来改变CS:IP的数值：JMP指令(转移指令)。

➤ 使用JMP指令修改CS:IP数值的方法：<br>
- ➀ 同时修改CS:IP的内容：使用形如"jmp 段地址:偏移地址"的形式来完成。例如：<br>
"jmp 2AE3:3"执行后：CS=2AE3H，IP=0003H，因此CPU将从2AE33H处开始读取指令。<br>
"jmp 3:0B16"执行后：CS=0003H，IP=0B16H，因此CPU将从00B46H处开始读取指令。
- ➁ 只想修改IP中的内容：使用形如"jmp 某合法寄存器"的形式来完成。例如：<br>
"jmp ax"执行前：ax=1000H，CS=2000H，IP=0003H；指令执行后：ax=1000H，CS=2000H，IP=1000H；
"jmp bx"执行前：bx=0B16H，CS=2000H，IP=0003H；指令执行后：bx=0B16H，CS=2000H，IP=0B16H。<br>
因此"jmp 某合法寄存器"指令的含义是：用寄存器中的数值修改段寄存器IP的值；"mov IP,ax"功能上类似于"mov IP,ax"(实际上mov指令不能用于修改段寄存器)。


### 十二：代码段
对于8086CPU，在编程时可以根据需要，将一组存储单元定义成一个段；可以将长度为N(N≤64kb)的一段代码，存放在一组地址连续、起始地址为16的倍数的存储单元中。这样，就定义了一个代码段。例如有一段代码：
```txt
mov ax,0000H  (B8 00 00 - 占用3byte)
add ax,0123H  (05 23 01 - 占用3byte)
mov bx,ax     (8B D8 - 占用2byte)
jmp bx        (FF E3 - 占用2byte)
```
上面的长度为10byte的代码，存放在一段地址为123B0H～123B9H的存储单元中，此时这段地址就可以被认为是一个代码段：段地址为123BH，代码段长度为10byte。进一步地，为了执行这段代码，需要将CS:IP段地址寄存器设置为：CS=123BH，IP=0000H(在执行代码段时，每读取一个存储单元中的内容，更新寄存器)。


## Reference
> \<assembly language by wangshuang 3ed\> chapter2 <br>

> 1 当使用inline数学公式且公式经过GFM排版之后都在同一行 使用`$...$`符号<br>
> 2 当希望数学公式单独成行或者经过GFM排版之后占用多行 应当使用`$$...$$`符号<br>
> 3 对于表示条件概率 需要表示竖线的时候`|` 应当使用`\mid` 而不是直接在键盘上打出`|` => 容易被编辑器认为是一个md制表符<br>
> 4 在md引入图片的时候 不要使用`<center>`和`</center>` 在这篇文档的编辑过程中vscode的preview插件在使用了上述符号之后 导致下一段的数学公式预览显示不正常<br>
> 5 使用md的时候 单独的两段文字上下需要空出一行<br>
> 6 想要强制换行的时候 需要使用`<br>`而不是`<enter>`<br>
> 7 特殊字符如果想要避免和md解析关键字冲突 应当使用\`\`将关键字包含在内 <br>
> 8 `<center><img src="/img/in-post/economics_4/xxx.png" width="60%"></center>` <br>
> 9 使用html设置图片文字环绕方式: <br>
    `<div>` <br>
        `<img src="/img_path" align="left" width="40%" hspace="" vspace=""/>` <br>
        `<p>paragraph1 around the picture</p>` <br>
        `<p>paragraph2 around the picture</p>` <br>
        `<p>paragraph3 around the picture</p>` <br>
    `</div>` <br>
> 10 `<font style="color:red; font-weight:bold">加粗蓝色</font>`用来设置字体颜色 <br>
> 问题脚注: ### ???problem😫problem???
