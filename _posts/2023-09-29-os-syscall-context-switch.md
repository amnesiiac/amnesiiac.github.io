---
layout: post
title: "syscall: context switch between user/kernel space (operating system)"
author: "melon"
date: 2023-09-29 15:44
categories: "2023"
tags:
  - os
---

### # introduction to kernel/user mode
the overview of computer system, software(user/kernel space) and hardware:

```txt
            
                          ┬ ┌──────────────────────────────────────┐ ┬
                          │ │             applications             │ │                   
                          │ └──────────────────┬───────────────────┘ │
                          │                    │                     │    user space (mode)
               -----------┼--------user application interface(libc)--┼-----------------------
                software  │                    │                     │  kernel space (mode)
                          │ ┌──────────────────+───────────────────┐ │ 
                          │ │           operating system           │ │                       
                          │ └────────────┬────────────+────────────┘ ┴
                          │              │            │
                          ┼ ┌────────────+────────────┴────────────┐
                          │ │ ┌─────┐    ┌───────────────────────┐ │
                          │ │ │ cpu │    │                       │ │
                hardware  │ │ ├─────┤    │  external I/O device  │ │
                          │ │ │ mem │    │                       │ │
                          │ │ └─────┘    └───────────────────────┘ │
                          ┴ └──────────────────────────────────────┘
            
```

kernel mode: able to access all hardware devices, able to execute all hardware intructions.  
user mode: able to execute part of hardware intructions, cannot execute I/O related or hardware control related instructions.  

```txt
   
                                           ┌ mov,add,sub,ret,push... (user space program available)
          ┌──────────────────┐ kernel mode │                         
          │ operating system ├─────────────┤
          └──────────────────┘ instruction │
                                           └ cli,sei,in,out...
                                             hardware controling related, directly operating hardware

```

the machine instructions can be accessed by user space program, but only part of them.

<hr>

### # dive a bit deeper into kernel/user mode by "hello world" program

```text
#include <stdio.h>                  // stdio: encapsulation of lower POSIX API with buffer mechanism

int main(){
    char str[] = "hello, world\n";  // str in mem
    printf(str);                    // print str to console (screen)
    return 0;
}
```

compile the above code, and use __strace__ tool to follow syscall:

```text
$ gcc test.c -o out                               # compile 
$ strace ./out                                    # the output need to be revised
execve("./out", ["*./out"], [/' 19 vars '/]) = 0
...
write(1, "hello, world\n", 13hello,world          # glibc user application interface defined API
      =13
)
...
+++ exited with 0 +++
```

so the printf function inside stdio actually invoke the glibc API __write__, thus we could directly invoke the glibc API in src code like:

```text
#include <unistd.h>                            // unistd: POSIX API without i/o buffer mechanism

int main(){
    char msg[] = "hello, world\n";
    write(STDOUT_FILENO, msg, sizeof(msg)-1);  // call POSIX glibc API write
    return 0;
}
```

compile the above code and use __gdb__ tool dive deep in asm code for __write__:

```text
$ gcc test.c -g -o out
$ gdb out                   # the output of gdb need to be revised
...
(gdb) break write           # break at write function
Breakpoint 1 at 0x400400
(gdb) run                   # enable step by step debug
...
(gdb) disassemble $pc,+500  # revert the src code to asm for analysis
...
```

use the disassemble asm code generated by gdb, the actually __write__ trace procedure is as follows:

```txt

 ┌─────────────────────────┐                                                      ┌─────────────────────┐┬
 │ # set syscall number    │                             (1)                   ┬--│---┌─────────────┐   ││
 │ # 1=write               │      user mode regs          |        application │  │   │ main(...)   │   ││
 │ mov  $0x1,%eax          │     ┌────────────────────────|┐              +    ┴--│---└──────┬──────┘   ││
 │ syscall                 │     │┌───┬───┬───┬───┬──┬──┐ |│              |    ┬--│---┌──────+──────┐   ││
 │                         │     ││rdi│rsi│rdx│r10│r9│r8+-┘│   user application│  │   │ printf(...) │   ││
 │ # kernel mode           │     │└───┴───┴───┴───┴──┴──┘  │   interface(glibc)│  │   ├─────────────┤   ││
 │ mov  $0x1,%eax          │     │ r11-r15                 │              |    │  │   │ write(...)  │   ││
 │ syscall                 │     │ rax rip rsp cpu-id-reg  │              |    ┴--│---└─────────────┘   ││
 │                         │     └──┼───┼───┼──────┼───────┘           (8)|       └──────────┬──────────┘┴
 │ # get param from stack  │        +-------------------------------------┘                  │
 │ mov  (%rsp),%rdi        │        |   |   |      └----------------┐                        │
 │                         │     (2)|   |   └----------------------┐|                        │
 │ # save ret value to rax │        |   └-------------------------┐||(3)              syscall│              user space
 │ mov  %rdx,%rax          │  ========================================================================================
 │                         │        └-----------------------┐     |||                     ┌──+──┐         kernel space
 │ # recycle heap space    │    ┌───────────────────────────|─────|||─────────────────────┤trap ├───────┐┬
 │ add  $0x8,%rsp          │    │ pt_regs                   |     |||                     └──┬──┘       ││
 │                         │    │┌──────────────────────────|────┐|||      (6)      ┌────────+────────┐ ││
 │ # return                │    ││┌───┬───┬───┬───┬──┬──┬───┴───┐│|||-------------->│ write(...)      │ ││
 │ retq                    │    │││rdi│rsi│rdx│r10│r9│r8│orig_ax││|||               └────────┬────────┘ ││
 └─────────────────────────┘    ││└───┴───┴───┴───┴──┴──┴───┬───┘│|||               ┌────────+────────┐ ││
                                ││ program counter: rip <---|-----┘||               │ sys_write(...){ │ ││
                                ││ func stack top: rsp <----|------┘|               │     ...         │ ││
                                ││ cpu id reg: flag <-------|-------┘          (7)  │     out (6)     │ ││
                                ││ return reg: ax <---------|-----------------------------...         │ ││
                                │└──────────────────────────|────┘                  │ }               │ ││
                                │ sys_call_table <----------┘                       └─────────────────┘ ││
                                │┌─┬─────┬─────────┐ (4)                                                ││
                                ││3│close│sys_close│                                                    ││
                                │├─┼─────┼─────────┤                                                    ││
                                ││2│open │sys_open │                                                    ││
                                │├─┼─────┼─────────┤                                                    ││
                                ││1│write│sys_write│                                                    ││
                                │├─┼─────┼─────────┤                                                    ││
                                ││.│     │         │                                                    ││
                                │└─┴─────┴─────────┘                                                    ││
                                └───────────────────────────────────────────────────────────────────────┘┴
(1)                      save params into regs
(2)                      pass syscall number from user mode rax reg to kernel mode orig_rax
(3)                      pass reg values to pt_regs
(4) mov  $0x1,%eax       check syscall table, syscall number=1, write -> sys_write 
(5) mov  (%rsp),%rdi     get param from stack, pass the param to syscall
(6) out                  output "hello, world" => to console (screen)     
(7) mov  %rdx,%rax       sys_write put ret value(succeed/fail) to ax reg
(8)                      get ret value from user mode rax reg, glibc return the value to main
```

<hr>

### # scenarios to switch from user space to kernel space
there are 3 main ways to apply for external resources when running user mode programs:  
1) syscall: the most common way for mode switch, could get manual of it by "man syscalls".   
2) interrupt (hardware/software): keyboard inputing and power outage...are all hardware interrupt, 32bit linux int80 is software interrupt.  
3) exception: todo.
